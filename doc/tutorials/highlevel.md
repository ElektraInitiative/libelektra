# High-level API (with code-generation)

Most applications don't need the flexibility of the low-level API (with `kdbGet`, `kdbSet`, etc.). In most cases an easy way to access the
configuration values ideally in a type-safe way would be preferred. This is why we created the high-level API.

There are two different ways of using the high-level API:

1. directly
2. via code-generation

The recommended way is via code-generation (which will be explained below). If you want to use the high-level API directly take a look
at [its documentation](/src/libs/highlevel/README.md). Please note, however, that certain features are only available through code-generation.

## Overview

The code-generation API builds on Elektra's specification feature. Instead of just using specifications at runtime, the code-generator parses
them as well and utilises them when generating configuration accessor functions.

## Writing a specification

The process of writing a full specification for your application is beyond the scope of this guide. We will just focus on the parts that are
absolutely necessary for using the code-generation API.

We will use this specification in the format of the `ni` plugin:

```ini
[]
mountpoint = myapp.ini

[mydouble]
type = double
default = 0.0

[myfloatarray/#]
type = float
default = 1.1
```

In Elektra a specification is defined through the metadata of keys in the `spec` namespace. The specification above contains metadata for
three keys the parent key (`@`), `@/mydouble` and `@/myfloatarray/#`. The `#` at the end of `myfloatarray/#` indicates that it is an array.

The `mountpoint` metadata on the parent key sets the name of our application's config file (the location is defined by Elektra), it should
be unique.

The `type` metadata specifies the type of a key. The available types can be found [here](/src/libs/highlevel/README.md#data-types). It is
important to set the `type`, because the code-generator will ignore all keys that don't have a `type`.

Because we want our getters to be unable to fail (makes error handling trivial), we need to provide a `default` value as well.

That's it. The code-generator just requires that each key (that you want to access) has a `type` and a `default` value.

_Note:_ You can also mark keys with the `require` metadata, if there is no reasonable default value. This is only recommended as a last
resort, but still preserves the guarantee that `elektraGet*` calls won't fail. If a `require`d key is missing, the initialization of the
`Elektra` handle will fail.

## Invoking the code-generator

The code-generator is a very powerful and flexible tool and has many options to tweak its output. If you want to know more about how to setup
everything just the way you want to, take a look at the man-pages [`kdb-gen(1)`](../help/kdb-gen.md) and
[`kdb-gen-highlevel(1)`](../help/kdb-gen-highlevel.md).

To get started the basic invocation of the code-generator should be enough:

```sh
kdb gen -F ni=spec.ini highlevel "/sw/example/myapp/#0/current" conf
```

This tells the code-generator that your application uses the parent key `/sw/example/myapp/#0/current` and that the output files should be
called `conf.*`. The argument `highlevel` just specifies which template to use and the option `-F ni=spec.ini` indicates that the
file `spec.ini` (in the `ni` plugin's format) contains the specification. While the code-generator can read a specification from the KDB,
we recommend you use the `-F` option. It keeps the KDB clean and can avoid troubles later on, when installing your application.

## Using the generated code

You can now take a look at `conf.h` and `conf.c` (the files generated by the compiler). Depending on the specification you used, these files
may be very long. They might also be formatted strangely, because of limitations in the code-generator. Feel free to reformat them with your
tool of choice, before inspecting them.

To explain how to use the generated code, lets take a look at some of `conf.h`.

```c
// conf.h - excerpt, reformatted, some comments and function bodies removed

/* file header ... */
/* helper macros ... */

/**
* Tag name for 'mydouble'
*
*/
#define ELEKTRA_TAG_MYDOUBLE Mydouble

/**
* Tag name for 'myfloatarray/#'
*
* Required arguments:
*
* - kdb_long_long_t index1: Replaces occurence no. 1 of # in the keyname.
*
*
*/
#define ELEKTRA_TAG_MYFLOATARRAY Myfloatarray

/* local macros ... */

static inline kdb_double_t ELEKTRA_GET (Mydouble) (Elektra * elektra) { /* ... */ }
static inline void ELEKTRA_SET (Mydouble) (Elektra * elektra, kdb_double_t value, ElektraError ** error) { /* ... */ }

static inline kdb_float_t ELEKTRA_GET (Myfloatarray) (Elektra * elektra, kdb_long_long_t index1) {  /* ... */ }
static inline void ELEKTRA_SET (Myfloatarray) (Elektra * elektra, kdb_float_t value, kdb_long_long_t index1, ElektraError ** error) { /* ... */ }

/* local macros ... */

int loadConfiguration (Elektra ** elektra, ElektraError ** error);
void printHelpMessage (Elektra * elektra, const char * usage, const char * prefix);
void specloadCheck (int argc, const char ** argv);

/* elektra* macros ... */
```

At the top of the file (after some helper macros) we can see all the `ELEKTRA_TAG_*` macros. We use these to allow for some flexibility in
how we generate the names of the `static inline` functions further down. You should always refer to your config values via these macros.
Additionally, the comments for these macros contain the documentation on what arguments are needed for accessing the tag in question. For
example to access the elements of the array `myfloatarray/#`, we obviously need to provide an index.

Next we see some local helper macros only used in this file.

Then the main part of the header: For each config value we generate an `ELEKTRA_GET(*)` and an `ELEKTRA_SET(*)` accessor function. All these
functions are `static inline`, because they just call other getter/setter functions with partially fixed arguments. In fact many of these
functions will only be a single line.

Then we undefine the local macros we defined before and declare the three initialization functions `loadConfiguration`, `printHelpMessage`
and `specloadCheck`.

At the end of the file you will find the `elektra*` convenience macros. These macros can be used to make accessing config values look more
like normal function calls and avoid the ugly double parentheses in e.g. `ELEKTRA_GET (...) (...)`.

### Obtaining an `Elektra` handle

We start at the bottom of our `conf.h` excerpt. `specloadCheck` is used to initiate specload mode, if needed. This mode makes your application
provide its specification to Elektra. How this works exactly is not so important (see [specload plugin](/src/plugins/specload/README.md)).
You only need to know, that `specloadCheck` should be called immediately at the start of your `main` function and that it only returns, when
your application is not in specload mode.

```c
int main (int argc, const char ** argv) {
    specloadCheck (argc, argv);
    // ...
}
```

To access your configuration, you first need to call `loadConfiguration` to get an `Elektra` handle for your application. This is done via
a snippet that is more or less the same for all applications:

```c
ElektraError * error = NULL;
Elektra * elektra = NULL;
int rc = loadConfiguration (&elektra, &error);

if (rc == -1)
{
    fprintf (stderr, "An error occurred while opening elektra: %s", elektraErrorDescription (error));
    elektraErrorReset (&error);
    exit (EXIT_FAILURE);
}

if (rc == 1)
{
    // help mode - application was called with '-h' or '--help'
    printHelpMessage (elektra, NULL, NULL);
    elektraClose (elektra);
    exit (EXIT_SUCCESS);
}
```

Next it is recommended, you change the default handler for fatal errors. By default we just call `exit (EXIT_FAILURE)`, since we don't know
how you log your errors and what cleanup may be needed.

```c
elektraFatalErrorHandler (elektra, onFatalError);
```

`onFatalError` will receive the fatal `ElektraError *`. It must at least call `elektraErrorReset` on the error and then call `exit()`.

### Reading config values

Once you have your `Elektra` instance, reading config values is easy. You just call one of the getter functions.

```c
kdb_double_t mydouble = ELEKTRA_GET (Mydouble) (elektra);
```

Alternatively, you can use the convenience macro `elektraGet` and/or the tag macros. We recommend you use one of the ways below, to avoid
problems in case we have to change how we generate the names of the `static inline` functions.

```c
kdb_double_t mydouble = ELEKTRA_GET (ELEKTRA_TAG_MYDOUBLE) (elektra);
kdb_double_t mydouble = elektraGet (elektra, ELEKTRA_TAG_MYDOUBLE);
```

To access config values that don't have static key name, like arrays, you have to supply additional arguments (and use `elektraGetV`):

```c
kdb_float_t myfloat0 = ELEKTRA_GET (ELEKTRA_TAG_MYFLOATARRAY) (elektra, 0);
float myfloat1 = ELEKTRA_GET (ELEKTRA_TAG_MYFLOATARRAY) (elektra, 1);
// or
kdb_float_t myfloat0 = elektraGetV (elektra, ELEKTRA_TAG_MYFLOATARRAY, 0);
kdb_float_t myfloat1 = elektraGetV (elektra, ELEKTRA_TAG_MYFLOATARRAY, 1);
```

Of course we also need to know, how big the `myfloatarray/#` array actually is. To that end we can use `ELEKTRA_SIZE` or `elektraSize`:

```c
kdb_long_long_t myfloat_size = ELEKTRA_SIZE (ELEKTRA_TAG_MYFLOATARRAY) (elektra);
// or
kdb_long_long_t myfloat_size = elektraSize (elektra, ELEKTRA_TAG_MYFLOATARRAY);
```

Please note that, while it shouldn't happen, if you setup everything correctly, calling a getter on a non-existent, wrongly typed or otherwise
inconvertible key is a fatal error. All fatal errors result in a call to the fatal error handler and therefore exit the application.

### Writing config values

Writing config values is just as easy as reading them.

```c
ElektraError * error = NULL;
ELEKTRA_SET (ELEKTRA_TAG_MYDOUBLE) (elektra, 3.141593, &error);
if (error == NULL) {
    // handle error
    elektraErrorReset (&error);
}
```

Admittedly writing is not quite as easy as reading, because of the error handling, but that is just a necessary evil when working in C. It
is important to call `elektraErrorReset`, if an error was returned. Calling a setter with a non-null error pointer is a fatal error.

Of course you can also use `elektraSet` (error handling omitted):

```c
elektraSet (elektra, ELEKTRA_TAG_MYDOUBLE, 3.141593, &error);
elektraSetV (elektra, ELEKTRA_TAG_MYFLOATARRAY, 2.718282f, &error, 2);
```

Note that `elektraSetV` takes the `ElektraError` argument before the variable arguments, while in `ELEKTA_SET` the error is always the last
argument. This is simply because of limitations in the C macro system.

There is not setter for array sizes. Since Elektra's low-level part supports discontinuous arrays, we simply change the array size whenever
necessary, if an array element setter is called. However, the high-level API has no support for discontinuous arrays, so take care not to
create holes in your arrays, if you want to iterate over them. Remember, accessing non-existent keys (and this includes array elements) is a
fatal error.

### Advanced concepts

The code-generator has some more advanced features that are supported out of the box. For example, you can read multiple config values at
once by utilising structs. The use of structs also allows for recursive configurations like menus (a menu can have submenus).

For more information take a look at the man-page [`kdb-gen-highlevel(1)`](../help/kdb-gen-highlevel.md).

## Compiling your application

Once you've written your application, you will want to compile it. This requires linking some libraries and adding to your include path.
The easiest way is to use CMake or pkg-config to find the needed compiler options. Examples on how set this up can be found in
[here](/examples/codegen/econf) and [here](/examples/codegen/tree).

The compiler invocation should look something like this:

```sh
cc myapp.c conf.c `pkg-config --cflags --libs elektra-codegen` -I. -o myapp -Wl,-rpath `pkg-config --variable=libdir elektra-codegen`
```

Note: At least C99 is required, so if your compiler defaults to an older version you'll need to add `-std=c99`.

## Running your application

Running your application is easy, just run the executable (e.g. `myapp`). While this might work out of the box, you will just get the default
configuration. To change the configuration you need to use `kdb`, which doesn't know about your specification yet, so you would need to set
the `type` metadata and all the other stuff that your application expects yourself. For every single key.

### Mounting the specification

A better solution is to inform Elektra (and `kdb`) about our specification. Then Elektra automatically copies metadata to where it should be.

First you need to mount your specification itself into the KDB. Mounting is basically the process of informing Elektra about a new part of
the KDB, similar to how mounting an external hard drive informs the OS about a new part of the file system.

```sh
sudo kdb mount -R noresolver myapp_spec.eqd "spec/sw/example/myapp/#0/current" specload app="$PWD/myapp"
```

The command above assumes that you also used the `kdb gen` command from [above](#invoking-the-code-generator) and that the `myapp` executable
is located in `$PWD`.

Now that Elektra knows about your specification, calling your application might work better, since metadata should now be copied, when you
set a config value via `kdb set`. However, there won't be any type checking. For that we need to enable the `type` plugin. While this could
be done manually, we can just let Elektra figure out which plugins we need and activate all of them.

This can be done with the `spec-mount` command:

```sh
sudo kdb spec-mount "/sw/example/myapp/#0/current"
```

Now finally your application is all setup.

### Configuring your application

To configure your application you can use `kdb`:

```sh
kdb set "/sw/example/myapp/#0/current/mydouble" 15.4
```

If you want to set a value system-wide (not just for your user) you can use `-N system`:

```sh
kdb set -N system "/sw/example/myapp/#0/current/mydouble" 15.4
```

Always use the cascading version of `kdb set` (i.e. the keyname begins with a slash `/`), otherwise type checking and other plugins might not
be called correctly.
