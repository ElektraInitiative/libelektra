{-# LANGUAGE OverloadedStrings, CPP #-}
module Elektra.Typechecker () where

import Elektra.Key
import Elektra.KeySet
import Elektra.KDB
import Elektra.Plugin
import Elektra.Ease
import Elektra.Invoke
import Elektra.SpecTranslator
import Elektra.SpecParser
import Elektra.Errors

import Control.Monad                (mapM_, forM_, (>=>), join)
import Control.Logger.Simple
import Data.Bool                    (bool)
import Data.List                    (intercalate, isPrefixOf)
import Data.Maybe                   (fromJust, listToMaybe)
import Foreign.Ptr
import System.IO.Temp               (writeTempFile)
import System.Directory             (removeFile, doesFileExist)
import System.Environment           (lookupEnv)
import Text.PrettyPrint

import Language.Haskell.Exts.Pretty
import Language.Haskell.Interpreter
import Language.Haskell.Interpreter.Unsafe

import qualified Data.Text as T

data CheckMode = Get | Set

typecheck :: Plugin -> KeySet -> Key -> CheckMode -> IO Bool
typecheck p ks k c = withGlobalLogging (LogConfig Nothing ("@ENABLE_LOGGER@" == "ON")) $ do
  name <- keyName k
  logDebugT $ "Parse Specifications at " ++ name
  logDebugT $ "Where we have the keys "
  keys <- ksList ks
  forM_ keys $ \dk -> do
    logDebugT $ show dk
    metakeys <- keyListMeta dk
    forM_ metakeys (logDebugT . show)

  conf <- elektraPluginGetConfig p
  logDebugT $ "the configuration is " ++ show conf

  -- Otherwise ksCut would remove keys, we don't want that behavior here
  ksc <- ksDup ks
  kscc <- ksCut ksc k

  -- prelude handling
  -- We load it via invoke + ini plugin as kdbOpen in here leads to unpredicted behavior combined with the process plugin
  logDebugT $ "the configuration is " ++ show conf
  let globalSpecPrelude = "@KDB_DB_SPEC@/prelude.ini"
  preludePath <- join . listToMaybe <$> sequence [
    -- #1: Environment variable (tests)
    lookupEnv "TYPECHECKER_PRELUDE",
    -- #2: Plugin Config (user custom preludes)
    ifKey (ksLookupByName conf "/prelude") (fmap Just . keyString) (return Nothing),
    -- #3: default global spec namespace (default)
    bool Nothing (Just globalSpecPrelude) <$> doesFileExist globalSpecPrelude
    -- #4: nothing otherwise
    ]
  logDebugT $ "Loading prelude located at " ++ show preludePath ++ " to " ++ name
  ps <- maybe (ksNew 0) (readPrelude p name) preludePath
  logDebugT $ "Prelude contained " ++ show ps
  ksAppend ps kscc
  logDebugT $ "Combined specifications are " ++ show ps

  typeSpecs <- parseTypeSpecifications k ps
  logDebugT $ "Got " ++ show (length typeSpecs) ++ " function specifications"
  mapM_ (logDebugT . show) typeSpecs

  keySpecs <- parseKeySpecifications k ps
  logDebugT $ "Got " ++ show (length keySpecs) ++ " key specifications"
  mapM_ (logDebugT . show) keySpecs

  putStepLn "Done Parsing all Specifications, now translate them."
  let rendered = renderStyle style {lineLength = 320} $ prettyPrim $ translateSpecifications typeSpecs keySpecs
  logDebugT rendered

  putStepLn "Done Translating all Specifications."
  specFile <- writeTempFile "/tmp/" "testSpecification.hs" rendered

  -- So we can override it for the build tests
  pdb <- lookupEnv "SANDBOX_PACKAGEDB"
  let args = filter (not . null) ["-package-db=" ++ maybe "@TYPECHECKER_GHC_PLUGIN@" id pdb, "-fplugin=Elektra.RegexTypeChecker", "-v"]
  r <- unsafeRunInterpreterWithArgs args (keyInterpreter specFile)
  removeFile specFile
  case r of
    Left err -> do
      let errStr = errorString err
      case c of
        Set -> triggerError 193 k errStr
        Get -> triggerWarnings 192 k errStr
      logDebugT errStr
      return True
    Right () -> return False
  where
    putStepLn s = logDebugT $ "\n" ++ s ++ "\n"
    readPrelude p name location = do
      prelude <- ksNew 0
      baseKey <- keyNewWithValue (name ++ "/elektra/spec/") location
      ini <- elektraPluginGetData p
      -- the handle is set otherwise opening the plugin would fail already
      -- likewise we could assume the data is set as well and use fromJust, but lets stay functional
      maybe (ksNew 0) (\i -> elektraInvoke2Args i "get" prelude baseKey >> ksDup prelude) ini

keyInterpreter :: FilePath -> InterpreterT IO ()
keyInterpreter specFile = do
  loadModules [specFile]
  say "Loaded our rendered specification, now we can infer the stuff in it."
  setTopLevelModules ["TestSpecification"]
  getModuleExports "TestSpecification" >>= mapM_ showTypes . filter isFun . filter (not . isPrefixOf "specElektraRawKey" . name)
  where
    showTypes c = typeOf (name c) >>= say . ((name c ++ " has an infered type of ") ++)
    isFun (Fun _) = True
    isFun _ = False

errorString :: InterpreterError -> String
errorString (WontCompile es) = intercalate "\n" (header : map unbox es)
  where
    header = "ERROR: Won't compile:"
    unbox (GhcError e) = e
errorString e = show e

say :: String -> Interpreter ()
say = liftIO . logDebugT

logDebugT :: MonadIO m => String -> m ()
logDebugT = logDebug . T.pack

openIni :: Plugin -> Key -> IO PluginStatus
openIni p k = do
  logDebugT "Opening ini"
  ini <- elektraInvokeOpen "ini" Nothing (Just k)
  ifHandle ini (return Error) (\i -> elektraPluginSetData p i >> return Success) 

closeIni :: Plugin -> Key -> IO PluginStatus
closeIni p k = do
  logDebugT "Closing ini"
  ini <- elektraPluginGetData p
  maybe (return Success) closeHandle ini
  where
    closeHandle ini = ifHandle ini (return Success) (\i -> elektraInvokeClose i (Just k) >> return Success)

elektraTypecheckerOpen :: Plugin -> Key -> IO PluginStatus
elektraTypecheckerOpen p k = openIni p k
hs_elektraHaskellOpen = elektraPluginOpenWith elektraTypecheckerOpen

elektraTypecheckerClose :: Plugin -> Key -> IO PluginStatus
elektraTypecheckerClose p k = closeIni p k
hs_elektraHaskellClose = elektraPluginCloseWith elektraTypecheckerClose

elektraTypecheckerGet :: Plugin -> KeySet -> Key -> IO PluginStatus
elektraTypecheckerGet p ks k = const NoUpdate <$> typecheck p ks k Get
hs_elektraHaskellGet = elektraPluginGetWith elektraTypecheckerGet

elektraTypecheckerSet :: Plugin -> KeySet -> Key -> IO PluginStatus
elektraTypecheckerSet p ks k = bool NoUpdate Error <$> typecheck p ks k Set
hs_elektraHaskellSet = elektraPluginSetWith elektraTypecheckerSet

elektraTypecheckerError :: Plugin -> KeySet -> Key -> IO PluginStatus
elektraTypecheckerError _ _ _ = return Success
hs_elektraHaskellError = elektraPluginErrorWith elektraTypecheckerError

foreign export ccall hs_elektraHaskellOpen :: Ptr Plugin -> Ptr Key -> IO Int
foreign export ccall hs_elektraHaskellClose :: Ptr Plugin -> Ptr Key -> IO Int
foreign export ccall hs_elektraHaskellGet :: Ptr Plugin -> Ptr KeySet -> Ptr Key -> IO Int
foreign export ccall hs_elektraHaskellSet :: Ptr Plugin -> Ptr KeySet -> Ptr Key -> IO Int
foreign export ccall hs_elektraHaskellError :: Ptr Plugin -> Ptr KeySet -> Ptr Key -> IO Int
