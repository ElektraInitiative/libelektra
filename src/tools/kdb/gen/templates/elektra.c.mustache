/**
 * @file
 *
 * @brief
 *
 * @copyright BSD License (see doc/LICENSE.md or https://www.libelektra.org)
 */

// clang-format off
{{=/*% %*/=}}

#include "/*%& header_file %*/"

/*%# more_headers %*/
#include "/*%& . %*/"
/*%/ more_headers %*/

/*%# enums %*/
ELEKTRA_TAG_DEFINITIONS (/*%& native_type %*/, /*%& type_name %*/, KDB_TYPE_ENUM, /*%& to_string %*/, /*%& from_key %*/)
/*%/ enums %*/

/*%# structs %*/
void elektraGet/*%& type_name %*/ (Elektra * elektra, const char * keyname, /*%& native_type %*/ * result)
{
	size_t nameLen = strlen(keyname);
	char * field = elektraCalloc ((nameLen + 1 + /*%& max_field_len %*/ + 1) * sizeof(char));
	strcpy (field, keyname);
	field[nameLen] = '/';
	++nameLen;

	/*%# fields %*/
	strncpy(&field[nameLen], "/*% key_name %*/", /*%& max_field_len %*/);
	/*%^ is_struct? %*/
	result->/*%& name %*/ = elektraGet/*%& type_name %*/ (elektra, field);
	/*%/ is_struct? %*/

	/*%/ fields %*/
	elektraFree (field);
}

void elektraGet/*%& type_name %*/ArrayElement (Elektra * elektra, const char * keyname, kdb_long_long_t index, /*%& native_type %*/ * result)
{
	size_t nameLen = strlen(keyname);
	char * field = elektraCalloc ((nameLen + 1 + /*%& max_field_len %*/ + 1 + ELEKTRA_MAX_ARRAY_SIZE) * sizeof(char));
	strcpy (field, keyname);
	field[nameLen] = '/';
	++nameLen;

	elektraWriteArrayNumber (&field[nameLen], index);
	nameLen = strlen(field);
	field[nameLen] = '/';
	++nameLen;

	/*%# fields %*/
	strncpy(&field[nameLen], "/*% key_name %*/", /*%& max_field_len %*/);
	/*%^ is_struct? %*/
	result->/*%& name %*/ = elektraGet/*%& type_name %*/ArrayElement (elektra, field);
	/*%/ is_struct? %*/

	/*%/ fields %*/
	elektraFree (field);
}

void elektraSet/*%& type_name %*/ (Elektra * elektra, const char * keyname, const /*%& native_type %*/ * value, ElektraError ** error)
{
	size_t nameLen = strlen(keyname);
	char * field = elektraCalloc ((nameLen + 1 + /*%& max_field_len %*/ + 1) * sizeof(char));
	strcpy (field, keyname);
	field[nameLen] = '/';
	++nameLen;

	/*%# fields %*/
	strncpy(&field[nameLen], "/*% key_name %*/", /*%& max_field_len %*/);
	elektraSet/*%& type_name %*/ (elektra, field, result->/*%& name %*/, error);
	if (error != NULL)
	{
		return;
	}

	/*%/ fields %*/
}

void elektraGet/*%& type_name %*/ArrayElement (Elektra * elektra, const char * keyname, kdb_long_long_t index, const /*%& native_type %*/ * value, ElektraError ** error)
{
	size_t nameLen = strlen(keyname);
	char * field = elektraCalloc ((nameLen + 1 + /*%& max_field_len %*/ + 1 + ELEKTRA_MAX_ARRAY_SIZE) * sizeof(char));
	strcpy (field, keyname);
	field[nameLen] = '/';
	++nameLen;

	elektraWriteArrayNumber (&field[nameLen], index);
	nameLen = strlen(field);
	field[nameLen] = '/';
	++nameLen;

	/*%# fields %*/
	strncpy(&field[nameLen], "/*% key_name %*/", /*%& max_field_len %*/);
	elektraSet/*%& type_name %*/ArrayElement (elektra, field, result->/*%& name %*/, error);
	if (error != NULL)
	{
		return;
	}

	/*%/ fields %*/
}
/*%/ structs %*/

/*%={{ }}=%*/
/**
 * Initializes an instance of Elektra for the application '{{{ parent_key }}}'.
 *
 * @param error An instance of ElektraError passed to elektraOpen().
 *
 * @return A newly allocated instance of Elektra. Has to bee disposed of with elektraClose().
 *
 * @see elektraOpen
 */{{=/*% %*/=}}
Elektra * /*%& init_function_name %*/ (ElektraError ** error)
{
	KeySet * defaults = /*%& defaults %*/;
	return elektraOpen ("/*% parent_key %*/", defaults, error);
}

// -------------------------
// Enum conversion functions
// -------------------------

/*%# enums %*/
int /*%& from_key %*/ (const Key * key, /*%& native_type %*/ * variable)
{
	const char * string;
	if (!elektraKeyToString (key, &string) || strlen (string) == 0)
	{
		elektraFatalError (elektra, elektraErrorConversionFromString (KDB_TYPE_ENUM, keyName (key), keyString (key)));
		return 0;
	}

	/*%# switch_from_string? %*/
	/*%& from_string_code %*/
	/*%/ switch_from_string? %*/
	/*%^ switch_from_string? %*/
	/*%# values %*/
	if (strcmp (string, "/*% string_value %*/") == 0)
	{
		return /*%& name %*/;
	}
	/*%/ values %*/
	/*%/ switch_from_string? %*/

	elektraFatalError (elektra, elektraErrorConversionFromString (KDB_TYPE_ENUM, keyName (key), keyString (key)));
	return 0;
}

char * /*%& to_string %*/ (/*%& native_type %*/ value)
{
	switch (value)
	{
	/*%# values %*/
	case /*%& name %*/:
		return "/*% string_value %*/";
	/*%/ values %*/
	}
}
/*%/ enums %*/