/**
 * @file
 *
 * @brief
 *
 * @copyright BSD License (see doc/LICENSE.md or https://www.libelektra.org)
 */

// clang-format off
{{=/*% %*/=}}
// clang-format on

#include "/*%& header_file %*/"

/*%# more_headers %*/
#include "/*%& . %*/"
/*%/ more_headers %*/

#ifdef __cplusplus
extern "C" {
#endif

#include <stdlib.h>
#include <string.h>

#include <kdbhelper.h>

#include <elektra/conversion.h>

/*%={{ }}=%*/
/**
 * Initializes an instance of Elektra for the application '{{{ parent_key }}}'.
 *
 * This MUST be called before anything was written to stdout, otherwise specload will fail.
 * If you have to write to stdout before calling this, you must handle the specload
 * communication yourself. You may use {{{ specload_function_name }}.
 *
 * @param elektra A reference to where the Elektra instance shall be stored.
 *                Has to be disposed of with elektraClose().
 * @param error   A reference to an ElektraError pointer. Will be passed to elektraOpen().
 *
 * @retval 0  on success, @p elektra will be set, @p error will be unchanged
 * @retval -1 on error, @p elektra will be unchanged, @p error will set
 * @retval 1  specload mode, exit as soon as possible and must DO NOT write anything to stdout,
 *            @p elektra and @p error are both unchanged
 * @retval 2  help mode, '-h' or '--help' was specified call {{{ help_function_name }}} and exit
 *            @p elektra and @p error are both unchanged
 *
 * @see elektraOpen
 */// {{=/*% %*/=}}
int /*%& init_function_name %*/ (Elektra ** elektra, ElektraError ** error)
{
	KeySet * defaults = /*%& defaults %*/;
	Elektra * e = elektraOpen ("/*% parent_key %*/", defaults, error);

	if (e == NULL)
	{
		return -1;
	}

	if (elektraGetBoolean (elektra, "/*% specload_name %*/"))
	{
		elektraClose (e);
		return /*%& specload_function_name %*/ ();
	}

	if (0 /* TODO: check if help mode */)
	{
		elektraClose (e);
		/*%& help_function_name %*/ ();
		return 2;
	}

	*elektra = e;
	return 0;
}

/**
 * Sends the specification over stdout in the format expected by specload.
 *
 * You MUST not output anything to stdout before or after invoking this function
 * and should exit as soon as possible after calling this function.
 *
 * @retval 1 on success
 * @retval -1 on error
 */
int /*%& specload_function_name %*/ (void)
{
	Key * errorKey = keyNew (0, KEY_END);

	KeySet * specloadConf = ksNew (1, keyNew ("system/sendspec", KEY_END), KS_END);
	ElektraInvokeHandle * specload = elektraInvokeOpen ("specload", specloadConf, errorKey);

	int result = elektraInvoke2Args (specload, "sendspec", ks, NULL);

	elektraInvokeClose (specload, errorKey);
	keyDel (errorKey);
	ksDel (specloadConf);

	return result == ELEKTRA_PLUGIN_STATUS_SUCCESS ? 1 : -1;
}

/**
 * Outputs the help message
 */
void /*%& help_function_name %*/ (void)
{
	// TODO
}

// -------------------------
// Enum conversion functions
// -------------------------

/*%# enums %*/
/*%# generate_typedef? %*/
ELEKTRA_KEY_TO_SIGNATURE (/*%& native_type %*/, /*%& type_name %*/)
{
	const char * string;
	if (!elektraKeyToString (key, &string) || strlen (string) == 0)
	{
		return 0;
	}

	/*%# switch_from_string? %*/
	/*%& from_string_code %*/
	/*%/ switch_from_string? %*/
	/*%^ switch_from_string? %*/
	/*%# values %*/
	if (strcmp (string, "/*% string_value %*/") == 0)
	{
		return /*%& name %*/;
	}
	/*%/ values %*/
	/*%/ switch_from_string? %*/

	return 0;
}

ELEKTRA_TO_STRING_SIGNATURE (/*%& native_type %*/, /*%& type_name %*/)
{
	switch (value)
	{
	/*%# values %*/
	case /*%& name %*/:
		return "/*% string_value %*/";
		/*%/ values %*/
	}
}
/*%/ generate_typedef? %*/
/*%/ enums %*/

// -------------------------
// Enum accessor functions
// -------------------------

/*%# enums %*/
ELEKTRA_GET_SIGNATURE (/*%& native_type %*/, /*%& type_name %*/)
{
	/*%& native_type %*/ result;
	const Key * key = elektraFindKey (elektra, keyname, KDB_TYPE_ENUM);
	if (!ELEKTRA_KEY_TO (/*%& type_name %*/) (key, &result))
	{
		elektraFatalError (elektra, elektraErrorConversionFromString (KDB_TYPE_ENUM, keyname, keyString (key)));
		return (/*%& native_type %*/) 0;
	}
	return result;
}

ELEKTRA_GET_ARRAY_ELEMENT_SIGNATURE (/*%& native_type %*/, /*%& type_name %*/)
{
	/*%& native_type %*/ result;
	const Key * key = elektraFindArrayElementKey (elektra, keyname, index, KDB_TYPE_ENUM);
	if (!ELEKTRA_KEY_TO (/*%& type_name %*/) (key, &result))
	{
		elektraFatalError (elektra, elektraErrorConversionFromString (KDB_TYPE_ENUM, keyname, keyString (key)));
		return (/*%& native_type %*/) 0;
	}
	return result;
}

ELEKTRA_SET_SIGNATURE (/*%& native_type %*/, /*%& type_name %*/)
{
	char * string = ELEKTRA_TO_STRING (/*%& type_name %*/) (value);
	if (string == 0)
	{
		*error = elektraErrorConversionToString (KDB_TYPE_ENUM, keyname);
		return;
	}
	elektraSetRawString (elektra, keyname, string, KDB_TYPE_ENUM, error);
	elektraFree (string);
}

ELEKTRA_SET_ARRAY_ELEMENT_SIGNATURE (/*%& native_type %*/, /*%& type_name %*/)
{
	char * string = ELEKTRA_TO_STRING (/*%& type_name %*/) (value);
	if (string == 0)
	{
		*error = elektraErrorConversionToString (KDB_TYPE_ENUM, keyname);
		return;
	}
	elektraSetRawStringArrayElement (elektra, keyname, index, string, KDB_TYPE_ENUM, error);
	elektraFree (string);
}
/*%/ enums %*/

// -------------------------
// Struct accessor functions
// -------------------------

/*%# structs %*/
/*%# alloc? %*/
ELEKTRA_STRUCT_FREE_SIGNATURE (/*%& native_type %*/ *, /*%& type_name %*/)
{
	if (*ptr == NULL)
	{
		return;
	}

	/*%# fields %*/
	/*%# is_struct? %*/
	/*%# alloc? %*/
	ELEKTRA_STRUCT_FREE (/*%& type_name %*/) (&(*ptr)->/*%& name %*/);
	/*%/ alloc? %*/
	/*%/ is_struct? %*/
	/*%/ fields %*/
	elektraFree (&ptr);
	*ptr = NULL;
}

ELEKTRA_GET_SIGNATURE (/*%& native_type %*/ *, /*%& type_name %*/)
{
	/*%& native_type %*/ *result = elektraCalloc (sizeof (/*%& native_type %*/));
	size_t nameLen = strlen (keyname);
	char * field = elektraCalloc ((nameLen + 1 + /*%& max_field_len %*/ +1) * sizeof (char));
	strcpy (field, keyname);
	field[nameLen] = '/';
	++nameLen;

	/*%# fields %*/
	strncpy (&field[nameLen], "/*% key_name %*/", /*%& max_field_len %*/);
	/*%# is_struct? %*/
	const char * refname = elektraGetRawString (elektra, field);
	if (refname != NULL && refname[0] != '\0')
	{
		char * refField = elektraCalloc ((nameLen + strlen (refname) + 1) * sizeof (char));
		strcpy (refField, field);
		strcpy (&refField[nameLen], refname);
		/*%# alloc? %*/
		result->/*%& name %*/ = ELEKTRA_GET (/*%& type_name %*/) (elektra, field);
		/*%/ alloc? %*/
		/*%^ alloc? %*/
		result->/*%& name %*/ = elektraCalloc (sizeof (/*%& native_type %*/));
		ELEKTRA_GET (/*%& type_name %*/) (elektra, field, result->/*%& name %*/);
		/*%/ alloc? %*/
		elektraFree (refField);
	}
	/*%/ is_struct? %*/
	/*%^ is_struct? %*/
	result->/*%& name %*/ = ELEKTRA_GET (/*%& type_name %*/) (elektra, field);
	/*%/ is_struct? %*/

	/*%/ fields %*/
	elektraFree (field);
	return result;
}

ELEKTRA_GET_ARRAY_ELEMENT_SIGNATURE (/*%& native_type %*/ *, /*%& type_name %*/)
{
	/*%& native_type %*/ *result = elektraCalloc (sizeof (/*%& native_type %*/));
	size_t nameLen = strlen (keyname);
	char * field = elektraCalloc ((nameLen + 1 + /*%& max_field_len %*/ +1 + ELEKTRA_MAX_ARRAY_SIZE) * sizeof (char));
	strcpy (field, keyname);
	field[nameLen] = '/';
	++nameLen;

	elektraWriteArrayNumber (&field[nameLen], index);
	nameLen = strlen (field);
	field[nameLen] = '/';
	++nameLen;

	/*%# fields %*/
	strncpy (&field[nameLen], "/*% key_name %*/", /*%& max_field_len %*/);
	/*%# is_struct? %*/
	const char * refname = elektraGetRawString (elektra, field);
	if (refname != NULL && refname[0] != '\0')
	{
		char * refField = elektraCalloc ((nameLen + strlen (refname) + 1) * sizeof (char));
		strcpy (refField, field);
		strcpy (&refField[nameLen], refname);
		/*%# alloc? %*/
		result->/*%& name %*/ = ELEKTRA_GET_ARRAY_ELEMENT (/*%& type_name %*/) (elektra, field, index);
		/*%/ alloc? %*/
		/*%^ alloc? %*/
		result->/*%& name %*/ = elektraCalloc (sizeof (/*%& native_type %*/));
		ELEKTRA_GET_ARRAY_ELEMENT (/*%& type_name %*/) (elektra, field, index, result->/*%& name %*/);
		/*%/ alloc? %*/
		elektraFree (refField);
	}
	/*%/ is_struct? %*/
	/*%^ is_struct? %*/
	result->/*%& name %*/ = ELEKTRA_GET_ARRAY_ELEMENT (/*%& type_name %*/) (elektra, field, index);
	/*%/ is_struct? %*/

	/*%/ fields %*/
	elektraFree (field);
	return result;
}
/*%/ alloc? %*/
/*%^ alloc? %*/
ELEKTRA_GET_OUT_PTR_SIGNATURE (/*%& native_type %*/, /*%& type_name %*/)
{
	size_t nameLen = strlen (keyname);
	char * field = elektraCalloc ((nameLen + 1 + /*%& max_field_len %*/ +1) * sizeof (char));
	strcpy (field, keyname);
	field[nameLen] = '/';
	++nameLen;

	/*%# fields %*/
	strncpy (&field[nameLen], "/*% key_name %*/", /*%& max_field_len %*/);
/*%# is_struct? %*/
/*%! should never happend %*/
#error "struct reference inside non-allocating struct is not supported"
	/*%/ is_struct? %*/
	/*%^ is_struct? %*/
	result->/*%& name %*/ = ELEKTRA_GET (/*%& type_name %*/) (elektra, field);
	/*%/ is_struct? %*/

	/*%/ fields %*/
	elektraFree (field);
}

ELEKTRA_GET_OUT_PTR_ARRAY_ELEMENT_SIGNATURE (/*%& native_type %*/, /*%& type_name %*/)
{
	size_t nameLen = strlen (keyname);
	char * field = elektraCalloc ((nameLen + 1 + /*%& max_field_len %*/ +1 + ELEKTRA_MAX_ARRAY_SIZE) * sizeof (char));
	strcpy (field, keyname);
	field[nameLen] = '/';
	++nameLen;

	elektraWriteArrayNumber (&field[nameLen], index);
	nameLen = strlen (field);
	field[nameLen] = '/';
	++nameLen;

	/*%# fields %*/
	strncpy (&field[nameLen], "/*% key_name %*/", /*%& max_field_len %*/);
/*%# is_struct? %*/
/*%! should never happend %*/
#error "struct reference inside non-allocating struct is not supported"
	/*%/ is_struct? %*/
	/*%^ is_struct? %*/
	result->/*%& name %*/ = ELEKTRA_GET_ARRAY_ELEMENT (/*%& type_name %*/) (elektra, field, index);
	/*%/ is_struct? %*/

	/*%/ fields %*/
	elektraFree (field);
}
/*%/ alloc? %*/

ELEKTRA_SET_SIGNATURE (const /*%& native_type %*/ *, /*%& type_name %*/)
{
	size_t nameLen = strlen (keyname);
	char * field = elektraCalloc ((nameLen + 1 + /*%& max_field_len %*/ +1) * sizeof (char));
	strcpy (field, keyname);
	field[nameLen] = '/';
	++nameLen;

	/*%# fields %*/
	strncpy (&field[nameLen], "/*% key_name %*/", /*%& max_field_len %*/);
	ELEKTRA_SET (/*%& type_name %*/) (elektra, field, value->/*%& name %*/, error);
	if (error != NULL)
	{
		return;
	}

	/*%/ fields %*/
}

ELEKTRA_SET_ARRAY_ELEMENT_SIGNATURE (const /*%& native_type %*/ *, /*%& type_name %*/)
{
	size_t nameLen = strlen (keyname);
	char * field = elektraCalloc ((nameLen + 1 + /*%& max_field_len %*/ +1 + ELEKTRA_MAX_ARRAY_SIZE) * sizeof (char));
	strcpy (field, keyname);
	field[nameLen] = '/';
	++nameLen;

	elektraWriteArrayNumber (&field[nameLen], index);
	nameLen = strlen (field);
	field[nameLen] = '/';
	++nameLen;

	/*%# fields %*/
	strncpy (&field[nameLen], "/*% key_name %*/", /*%& max_field_len %*/);
	ELEKTRA_SET_ARRAY_ELEMENT (/*%& type_name %*/) (elektra, field, index, value->/*%& name %*/, error);
	if (error != NULL)
	{
		return;
	}

	/*%/ fields %*/
}
/*%/ structs %*/

#ifdef __cplusplus
}
#endif
