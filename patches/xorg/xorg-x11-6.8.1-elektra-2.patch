diff -Naur xc.orig/programs/Xserver/hw/xfree86/common/Imakefile xc/programs/Xserver/hw/xfree86/common/Imakefile
--- xc.orig/programs/Xserver/hw/xfree86/common/Imakefile	2006-02-07 16:18:26.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/common/Imakefile	2006-02-07 16:29:02.000000000 +0100
@@ -77,6 +77,11 @@
 BACKTRACE_DEFS = -DHAVE_EXECINFO_H
 #endif
 
+#if defined(UseElektra)
+ELEKTRA_DEFINES = -DELEKTRA
+#endif
+
+
 SRCS =	\
 	xf86Configure.c \
 	xf86Bus.c \
@@ -207,6 +212,11 @@
 	      $(CONFIG_DEFINES) $(XKBDEFRULESDEFS) $(VENDORSUPPORTDEFS) \
 	      $(VENDOR_DEFINES) -DXF86PM
 
+#if defined(UseElektra)
+XCONFIGDEFINES += $(ELEKTRA_DEFINES)
+#endif
+
+
 AllTarget($(OFILES))
 
 SpecialCObjectRule(xf86Bus,NullParameter,$(BUGMSG) $(VGAINCLUDES))
diff -Naur xc.orig/programs/Xserver/hw/xfree86/common/xf86Config.c xc/programs/Xserver/hw/xfree86/common/xf86Config.c
--- xc.orig/programs/Xserver/hw/xfree86/common/xf86Config.c	2006-02-07 16:18:26.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/common/xf86Config.c	2006-02-07 16:38:14.000000000 +0100
@@ -44,6 +44,11 @@
  *      Marc La France <tsi@XFree86.Org>
  *      Egbert Eich <eich@XFree86.Org>
  *      ... and others
+ *
+ * Adapted to the Elektra key/value pair database:
+ *    Avi Alkalay <avi@unix.sh> november 2004
+ *    Elektra Project :: http://elektra.sourceforge.net
+ *
  */
 
 #ifdef HAVE_XORG_CONFIG_H
@@ -66,6 +71,10 @@
 #include "xf86Priv.h"
 #include "xf86_OSlib.h"
 
+#ifdef ELEKTRA
+#include "elektra.h"
+#endif
+
 #include "globals.h"
 
 #ifdef XINPUT
@@ -2600,6 +2609,36 @@
 	if (xf86ConfigFile)
 	    from = X_CMDLINE;
 
+#ifdef ELEKTRA
+	        /*
+		 * This is what we'll do:
+		 * 
+		 *	1. First look for configurations at the key database
+		 *	2. If found
+		 *		2.1. Put it on xf86configptr struct
+		 *	3. If not found
+		 *	3.1. Read some xorg.conf file and put parsed stuff on
+		 *	     xf86configptr structure
+		 *	3.2  Convert xf86configptr struct into a KeySet
+		 *	3.3  Write the KeySet to the key database
+		 *	3.4  Free KeySet and xf86configptr struct
+		 *	3.5  Get configuration keys again from the
+		 *	     just-commited key database into xf86configptr struct
+		 *	4. xf86configptr struct is ready to go
+		 **/
+	xf86configptr=xf86getConfigKeys("system/sw/xorg/current");
+	if (xf86configptr)
+ 		xf86MsgVerb(from, 0, "Using configuration keys from: \"%s\"\n",
+				"system/sw/xorg/current");
+ 	else xf86configptr=xf86getConfigKeys("system/sw/xorg");
+	if (xf86configptr)
+		xf86MsgVerb(from, 0, "Using configuration keys from: \"%s\"\n",
+				"system/sw/xorg");
+ 	else {
+		/* fallback to old configuration file */
+#endif
+		
+	
 	filename = xf86openConfigFile(searchpath, xf86ConfigFile, PROJECTROOT);
 	if (filename) {
 	    xf86MsgVerb(from, 0, "Using config file: \"%s\"\n", filename);
@@ -2611,7 +2650,50 @@
 	    xf86ErrorFVerb(0, "\n");
 	    return CONFIG_NOFILE;
 	}
-    }
+#ifdef ELEKTRA
+
+	{
+ 		KeySet *ks;
+ 		char *rootkey="system/sw/xorg/current";
+		int ret;
+		
+ 		if ((xf86configptr = xf86readConfigFile ()) == NULL) {
+			xf86Msg(X_ERROR, "Problem parsing the config file\n");
+			return CONFIG_PARSE_ERROR;
+		}
+		xf86closeConfigFile ();
+		
+		/* Convert the parsed configuration into keys..... */
+		
+ 		/* Put the in-memory X configurations in a KeySet, also in memory */
+		ks=xf86collectConfigKeys(rootkey,xf86configptr);
+		
+		xf86MsgVerb(from, 0,
+				"Old \"%s\" configurations converted to key/value pairs.\n",
+				filename);
+		xf86MsgVerb(from, 0,
+				"Setting key/value pairs under: \"%s\"\n", rootkey);
+		
+		/* Really commit to the Key database */
+		kdbOpen();
+		ksRewind(ks);
+		ret=kdbSetKeys(ks);
+		if (ret != 0) {
+			Key *problem;
+ 			char keyname[300]="";
+			
+ 			problem=ksCurrent(ks);
+			if (problem) keyGetFullName(problem,keyname,sizeof(keyname));
+			xf86ErrorFVerb(0, "Error while setting key \"%s\"\n", keyname);
+		}
+		ksClose(ks);
+	}
+   	} /* if (xf86configptr) */
+    } /* if (! autoconfig) */
+#else /* ELEKTRA */
+    } /* if (! autoconfig) */
+
+	
      
     if ((xf86configptr = xf86readConfigFile ()) == NULL) {
 	xf86Msg(X_ERROR, "Problem parsing the config file\n");
@@ -2619,6 +2701,9 @@
     }
     xf86closeConfigFile ();
 
+#endif /* ! ELEKTRA */
+	/* xf86configptr is ready to go... */
+
     /* Initialise a few things. */
 
     /*
diff -Naur xc.orig/programs/Xserver/hw/xfree86/parser/elektra.c xc/programs/Xserver/hw/xfree86/parser/elektra.c
--- xc.orig/programs/Xserver/hw/xfree86/parser/elektra.c	1970-01-01 01:00:00.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/parser/elektra.c	2006-02-07 16:21:06.000000000 +0100
@@ -0,0 +1,3651 @@
+/* $Id$ */
+
+
+/*
+ * Copyright (c) 2004 by Avi Alkalay <avi at unix.sh>
+ *
+ * The Elektra Project :: http://elektra.sourceforge.net
+ *
+ */
+
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#include <kdb.h> /* Elektra */
+
+#include "xf86Parser.h"
+#include "xf86tokens.h"
+#include "Configint.h"
+
+static char *
+prependRoot (char *pathname)
+{
+#ifndef __EMX__
+	return pathname;
+#else
+	/* XXXX caveat: multiple path components in line */
+	return (char *) __XOS2RedirRoot (pathname);
+#endif
+}
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Files.c::xf86parseFilesSection() function
+ *
+ * Fetches keys under [rootKey]/Files and put in
+ * a XF86ConfFilesPtr struct.
+ *
+ */
+XF86ConfFilesPtr
+xf86getFiles (const char *rootKey)
+{
+	Key *key;
+	int ret;
+	size_t dataSize;
+
+	/* funky declaration of internals.... */
+	parsePrologue (XF86ConfFilesPtr, XF86ConfFilesRec)
+
+	/* Get the FontPath */
+	key = keyNew(KEY_SWITCH_END);
+	ret=kdbGetKeyByParent(rootKey,"Files/FontPath",key);
+	if (ret == 0) {
+		dataSize = 100 + keyGetDataSize(key);
+		ptr->file_fontpath = xf86confmalloc (dataSize);
+		ptr->file_fontpath = prependRoot (ptr->file_fontpath);
+		keyGetString (key, ptr->file_fontpath, dataSize);
+	}
+	keyClose(key);
+
+
+	/* Get the RGBPath */
+	keyInit(key);
+	ret=kdbGetKeyByParent(rootKey,"Files/RgbPath", key);
+	if (ret == 0) {
+		dataSize = 100 + keyGetDataSize(key);
+		ptr->file_rgbpath = xf86confmalloc (dataSize);
+		ptr->file_rgbpath = prependRoot (ptr->file_rgbpath);
+		keyGetString (key, ptr->file_rgbpath, dataSize);
+	}
+	keyClose(key);
+
+
+	/* Get the ModulePath */
+	keyInit(key);
+	ret=kdbGetKeyByParent(rootKey,"Files/ModulePath",key);
+	if (ret == 0) {
+		dataSize = 100 + keyGetDataSize(key);
+		ptr->file_modulepath = xf86confmalloc (dataSize);
+		ptr->file_modulepath = prependRoot (ptr->file_modulepath);
+		keyGetString (key, ptr->file_modulepath, dataSize);
+	}
+	keyClose(key);
+
+
+	/* Get the InputDevices */
+	keyInit(key);
+	ret=kdbGetKeyByParent(rootKey,"Files/InputDevices",key);
+	if (ret == 0) {
+		dataSize = 100 + keyGetDataSize(key);
+		ptr->file_inputdevs = xf86confmalloc (dataSize);
+		ptr->file_inputdevs = prependRoot (ptr->file_inputdevs);
+		keyGetString (key, ptr->file_inputdevs, dataSize);
+	}
+	keyClose(key);
+	
+
+	/* Get the LogFile */
+	keyInit(key);
+	ret=kdbGetKeyByParent(rootKey,"Files/LogFile",key);
+	if (ret == 0) {
+		dataSize = 100 + keyGetDataSize(key);
+		ptr->file_logfile = xf86confmalloc (dataSize);
+		ptr->file_logfile = prependRoot (ptr->file_logfile);
+		keyGetString (key, ptr->file_logfile, dataSize);
+	}
+	keyClose(key);
+
+
+#ifdef DEBUG
+	printf ("File keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+/*
+ * Elektra version of Files.c::xf86printFileSection function
+ *
+ * Generates a KeySet from a passed XF86ConfFilesPtr struct plus
+ * a root key name.
+ *
+ */
+void
+xf86addFiles(KeySet *ks, const char *root, XF86ConfFilesPtr ptr) {
+	char buffer[300];
+	Key *key=NULL;
+
+	if (ptr->file_logfile) {
+		strcpy(buffer,root);
+		strcat(buffer,"/Files/LogFile");
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, ptr->file_logfile,
+				KEY_SWITCH_END);
+
+		ksAppend(ks,key);
+	}
+
+	if (ptr->file_rgbpath) {
+		strcpy(buffer,root);
+		strcat(buffer,"/Files/RgbPath");
+		key = keyNew(buffer,
+				KEY_SWITCH_VALUE, ptr->file_rgbpath,
+				KEY_SWITCH_END);
+
+		ksAppend(ks,key);
+	}
+
+	if (ptr->file_modulepath) {
+		strcpy(buffer,root);
+		strcat(buffer,"/Files/ModulePath");
+		key = keyNew(buffer,
+				KEY_SWITCH_VALUE, ptr->file_modulepath,
+				KEY_SWITCH_END);
+
+		keySetName(key,buffer);
+		keySetString(key,ptr->file_modulepath);
+
+		ksAppend(ks,key);
+	}
+
+	if (ptr->file_inputdevs) {
+		strcpy(buffer,root);
+		strcat(buffer,"/Files/InputDevices");
+		key = keyNew(buffer,
+				KEY_SWITCH_VALUE, ptr->file_inputdevs,
+				KEY_SWITCH_END);
+
+		ksAppend(ks,key);
+	}
+
+	if (ptr->file_fontpath) {
+		strcpy(buffer,root);
+		strcat(buffer,"/Files/FontPath");
+		key = keyNew(buffer,
+				KEY_SWITCH_VALUE, ptr->file_fontpath,
+				KEY_SWITCH_END);
+
+		ksAppend(ks,key);
+	}
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/* Begin options handling helpers */
+
+/*
+ * Elektra equivalent for Flags.c::xf86newOption()
+ *
+ * Helper function to create an XF86OptionPtr from a Key.
+ *
+ */
+XF86OptionPtr
+keyToOption(Key *key)
+{
+	XF86OptionPtr option;
+
+	char *optionName = NULL;
+	char *data = NULL;
+	size_t optionSize=0;
+	size_t dataSize=0;
+	size_t commentSize=0;
+
+	optionName = xf86confmalloc (optionSize=keyGetBaseNameSize(key));
+	commentSize=keyGetCommentSize(key);
+	dataSize=keyGetDataSize(key);
+	if (dataSize>1) {
+		/* if we have here more than a simple NULL string */
+		data = xf86confmalloc (dataSize);
+	}
+
+	if (optionName)
+		keyGetBaseName(key,optionName,optionSize);
+	if (data)
+		keyGetString(key,data,dataSize);
+
+	option = xf86newOption (optionName,data);
+	if (commentSize) {
+		option->opt_comment = xf86confmalloc (commentSize);
+		if (option->opt_comment)
+			keyGetComment(key,option->opt_comment,commentSize);
+	}
+
+	return option;
+}
+
+
+
+/*
+ * Helper function to create an linked list of XF86OptionPtr from a KeySet.
+ *
+ */
+XF86OptionPtr
+ksToOptions(KeySet *ks)
+{
+	Key *key;
+	XF86OptionPtr option=NULL;
+	XF86OptionPtr options=NULL;
+
+	/* reset internal cursor */
+	ksRewind(ks);
+	while ((key=ksNext(ks))) {
+		option=keyToOption(key);
+		options=((XF86OptionPtr)xf86addListItem((glp)options,
+			(glp)option));
+	}
+
+	return options;
+}
+
+
+
+/*
+ * Elektra version of Flags.c::xf86printOptionList()
+ *
+ * Generates a KeySet from a passed linked list of XF86OptionPtr struct
+ * plus a root key name.
+ *
+ */
+void
+xf86addOptions(KeySet *ks,const char *root,XF86OptionPtr list) {
+	char buffer[300];
+	Key *key=NULL;
+
+	if (!list)
+		return;
+	while (list) {
+		strcpy(buffer,root);
+		strcat(buffer,"/");
+		strcat(buffer,list->opt_name);
+
+		key = keyNew(buffer,
+				KEY_SWITCH_COMMENT, list->opt_comment,
+				KEY_SWITCH_END);
+
+		if (list->opt_val) keySetString(key,list->opt_val);
+		/* else keySetString(key,"1"); */
+
+		list = list->list.next;
+
+		ksAppend(ks,key);
+	}
+}
+
+
+/* End options handling helpers */
+
+
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Flags.c::xf86parseFlagsSection() function
+ *
+ * Fetch keys under [rootKey]/ServerFlags and put in
+ * a XF86ConfFlagsPtr struct.
+ *
+ */
+XF86ConfFlagsPtr
+xf86getFlags (const char *rootKey)
+{
+	KeySet *optionKeys;
+	char serverFlagsRoot[sizeof(rootKey)+50];
+
+	XF86OptionPtr options = NULL;
+	XF86ConfFlagsPtr ptr=NULL; /* we'll return this */
+	
+	strcpy(serverFlagsRoot,rootKey);
+	strcat(serverFlagsRoot,"/ServerFlags");
+
+	optionKeys = ksNew();
+	kdbGetChildKeys(serverFlagsRoot,optionKeys,KDB_O_SORT);
+	if (ksGetSize(optionKeys))
+		options=ksToOptions(optionKeys);
+	ksDel(optionKeys);
+
+	if (options) {
+		ptr=xf86confmalloc(sizeof(XF86ConfFlagsRec));
+		memset(ptr,0,sizeof(XF86ConfFlagsRec));
+		ptr->flg_option_lst=options;
+	}
+
+#ifdef DEBUG
+	printf ("Flags keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+
+/*
+ * Elektra version of Flags.c::xf86printServerFlagsSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfFlagsPtr struct
+ * plus a root key name.
+ *
+ */
+void
+xf86addFlags(KeySet *ks, const char *root, XF86ConfFlagsPtr flags) {
+	char buffer[300];
+	XF86OptionPtr p;
+
+	if ((!flags) || (!flags->flg_option_lst))
+		return;
+	p = flags->flg_option_lst;
+
+	strcpy(buffer,root);
+	strcat(buffer,"/ServerFlags");
+
+	xf86addOptions(ks,buffer,p);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Input.c::xf86parseInputSection() function.
+ *
+ * Fetch keys under [rootKey]/InputDevices and put in a XF86ConfInputPtr.
+ * All input devices, including keyboard and mice are there.
+ *
+ */
+XF86ConfInputPtr
+xf86getInput (const char *rootKey)
+{
+	KeySet *inputDevs;
+	Key *current;
+	int ret;
+	char localRootKey[sizeof(rootKey)+50];
+
+	XF86ConfInputPtr ptr = NULL; /* this is what we'll return */
+
+	strcpy(localRootKey,rootKey);
+	strcat(localRootKey,"/InputDevices");
+
+	inputDevs = ksNew();
+	/*
+	 * There should be only folders right under InputDevices/.
+	 * So we are interested only in the skeleton.
+	 */
+	kdbGetChildKeys(localRootKey, inputDevs,
+		KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+
+	if (ksGetSize(inputDevs)) {
+		ksRewind(inputDevs);
+		while ((current=ksNext(inputDevs))) {
+			/* each entry we'll process is an InputDevice */
+			XF86ConfInputPtr inputdev;
+			size_t identSize,dataSize;
+			Key *driver;
+			KeySet *optionKeys;
+			char *options=NULL;
+
+
+			inputdev=xf86confcalloc(1,sizeof(XF86ConfInputRec));
+			memset(inputdev,0,sizeof(XF86ConfInputRec));
+
+			identSize=keyGetBaseNameSize(current);
+
+			inputdev->inp_identifier=xf86confmalloc(identSize);
+			if (inputdev->inp_identifier)
+				keyGetBaseName(current,inputdev->inp_identifier,identSize);
+
+			/* Get the driver */
+			driver = keyNew(KEY_SWITCH_END);
+			ret=kdbGetKeyByParentKey(current,"Driver",driver);
+			if (ret == 0) {
+				dataSize=keyGetDataSize(driver);
+				inputdev->inp_driver=xf86confmalloc(dataSize);
+				keyGetString(driver,inputdev->inp_driver,dataSize);
+				dataSize=keyGetCommentSize(driver);
+				if (dataSize) {
+					inputdev->inp_comment=xf86confmalloc(dataSize);
+					keyGetComment(driver,inputdev->inp_comment,dataSize);
+				}
+			}
+			keyDel(driver);
+
+			/* Now get this device's options */
+			dataSize=keyGetFullNameSize(current)+30;
+			options=xf86confmalloc(dataSize);
+			keyGetFullName(current,options,dataSize);
+			strcat(options,"/Options");
+
+			optionKeys = ksNew();
+			kdbGetChildKeys(options,optionKeys,KDB_O_SORT);
+			if (ksGetSize(optionKeys))
+				inputdev->inp_option_lst=ksToOptions(optionKeys);
+			xf86conffree (options);
+			ksDel(optionKeys);
+
+			/* Finished with this device. Now add to our devices list */
+			if (ptr) ptr=(XF86ConfInputPtr)
+				xf86addListItem ((glp) ptr, (glp) inputdev);
+			else  ptr=inputdev;
+		}
+	}
+
+	ksDel(inputDevs);
+
+#ifdef DEBUG
+	printf ("InputDevice keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+/*
+ * Elektra version of Input.c::xf86printInputSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfInputPtr struct
+ * plus a root key name.
+ *
+ */
+void
+xf86addInput(KeySet *ks, const char *root, XF86ConfInputPtr ptr) {
+	char buffer[300];
+	Key *key;
+
+	while (ptr) {
+		sprintf(buffer,"%s/InputDevices/%s/Driver",root,ptr->inp_identifier);
+		key = keyNew(buffer,
+			KEY_SWITCH_VALUE, ptr->inp_driver,
+			KEY_SWITCH_COMMENT, ptr->inp_comment,
+			KEY_SWITCH_END);
+		
+		ksAppend(ks,key);
+
+		sprintf(buffer,"%s/InputDevices/%s/Options",root,ptr->inp_identifier);
+		xf86addOptions(ks,buffer,ptr->inp_option_lst);
+
+		ptr=ptr->list.next;
+	}
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Device.c::xf86parseDeviceSection() function
+ *
+ * Fetch keys under [rootKey]/Devices.
+ * All video cards are there.
+ *
+ * TODO: check int and float conversions
+ *
+ */
+
+XF86ConfDevicePtr
+xf86getDevice (const char *rootKey)
+{
+	KeySet *devices;
+	Key *current;
+	int ret;
+	char localRootKey[sizeof(rootKey)+50];
+
+	XF86ConfDevicePtr ptr = NULL;
+
+	strcpy(localRootKey,rootKey);
+	strcat(localRootKey,"/Devices");
+
+	devices = ksNew();
+	/*
+	 * There should be only folders right under Devices/.
+	 * So we are interested only in the skeleton.
+	 */
+	kdbGetChildKeys(localRootKey, devices,
+		KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+
+
+	if (ksGetSize(devices)) {
+		ksRewind(devices);
+		while ((current=ksNext(devices))) {
+			/* each entry we'll process is a Device */
+			XF86ConfDevicePtr device;
+			KeySet *optionKeys;
+			Key *genericKey;
+			size_t identSize,dataSize;
+			char *options=NULL;
+			char buffer[100];
+
+
+			device=xf86confcalloc(1,sizeof(XF86ConfDeviceRec));
+			memset(device,0,sizeof(XF86ConfDeviceRec));
+
+			/* Zero is a valid value for these */
+			device->dev_chipid = -1;
+			device->dev_chiprev = -1;
+			device->dev_irq = -1;
+			
+			identSize=keyGetBaseNameSize(current);
+			device->dev_identifier=xf86confmalloc(identSize);
+			if (device->dev_identifier)
+				keyGetBaseName(current,device->dev_identifier,identSize);
+
+			/* Get Vendor */
+			genericKey = keyNew(KEY_SWITCH_END);
+			ret=kdbGetKeyByParentKey(current,"VendorName",genericKey);
+			if (ret == 0) {
+				dataSize=keyGetDataSize(genericKey);
+				device->dev_vendor=xf86confmalloc(dataSize);
+				keyGetString(genericKey,device->dev_vendor,dataSize);
+			}
+			keyClose(genericKey);
+
+
+			/* Get Board */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"BoardName",genericKey);
+			if (ret == 0) {
+				dataSize=keyGetDataSize(genericKey);
+				device->dev_board=xf86confmalloc(dataSize);
+				keyGetString(genericKey,device->dev_board,dataSize);
+			}
+			keyClose(genericKey);
+
+			/* Get Chipset */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"Chipset",genericKey);
+			if (ret == 0) {
+				dataSize=keyGetDataSize(genericKey);
+				device->dev_chipset=xf86confmalloc(dataSize);
+				keyGetString(genericKey,device->dev_chipset,dataSize);
+			}
+			keyClose(genericKey);
+
+			/* Get Card */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"Card",genericKey);
+			if (ret == 0) {
+				dataSize=keyGetDataSize(genericKey);
+				device->dev_card=xf86confmalloc(dataSize);
+				keyGetString(genericKey,device->dev_card,dataSize);
+			}
+			keyClose(genericKey);
+
+			/* Get Driver */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"Driver",genericKey);
+			if (ret == 0) {
+				dataSize=keyGetDataSize(genericKey);
+				device->dev_driver=xf86confmalloc(dataSize);
+				keyGetString(genericKey,device->dev_driver,dataSize);
+			}
+			keyClose(genericKey);
+			
+			/* Get Ramdac */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"Ramdac",genericKey);
+			if (ret == 0) {
+				dataSize=keyGetDataSize(genericKey);
+				device->dev_ramdac=xf86confmalloc(dataSize);
+				keyGetString(genericKey,device->dev_ramdac,dataSize);
+			}
+			keyClose(genericKey);
+			
+			/* Get DacSpeed */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"DacSpeed",genericKey);
+			if (ret == 0) {
+				int i;
+				char *speed=buffer;
+				char *speedEnd=speed;
+
+				for (i = 0; i < CONF_MAXDACSPEEDS; i++)
+					device->dev_dacSpeeds[i] = 0;
+				
+				
+				dataSize=keyGetDataSize(genericKey);
+				keyGetString(genericKey,buffer,dataSize);
+				
+				i=0;
+				do {
+					speed=speedEnd;
+					device->dev_dacSpeeds[i] =
+						(int) (strtod(speed,&speedEnd) * 1000.0 + 0.5);
+				} while (i<CONF_MAXDACSPEEDS && speed!=speedEnd);
+			}
+			keyClose(genericKey);
+
+			/* Get VideoRam */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"VideoRam",genericKey);
+			if (ret == 0) {
+				keyGetString(genericKey,buffer,sizeof(buffer));
+				device->dev_videoram=strtol(buffer, NULL, 10);
+			}
+			keyClose(genericKey);
+
+			/* Get BIOSBase */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"BIOSBase",genericKey);
+			if (ret == 0) {
+				keyGetString(genericKey,buffer,sizeof(buffer));
+				device->dev_bios_base=strtol(buffer, NULL, 10);
+			}
+			keyClose(genericKey);
+			
+			
+			
+			/* Get MemBase */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"MemBase",genericKey);
+			if (ret == 0) {
+				keyGetString(genericKey,buffer,sizeof(buffer));
+				device->dev_mem_base=strtol(buffer, NULL, 10);
+			}
+			keyClose(genericKey);
+
+			
+			
+			
+			/* Get IOBase */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"IOBase",genericKey);
+			if (ret == 0) {
+				keyGetString(genericKey,buffer,sizeof(buffer));
+				device->dev_io_base=strtol(buffer, NULL, 10);
+			}
+			keyClose(genericKey);
+			
+			
+
+			
+			/* Get ClockChip */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"ClockChip",genericKey);
+			if (ret == 0) {
+				dataSize=keyGetDataSize(genericKey);
+				device->dev_clockchip=xf86confmalloc(dataSize);
+				keyGetString(genericKey,device->dev_clockchip,dataSize);
+			}
+			keyClose(genericKey);
+
+
+			
+			/* Get ChipID */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"ChipID",genericKey);
+			if (ret == 0) {
+				keyGetString(genericKey,buffer,sizeof(buffer));
+				device->dev_chipid=strtol(buffer, NULL, 10);
+			}
+			keyClose(genericKey);
+			
+			
+			
+			/* Get ChipRev */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"ChipRev",genericKey);
+			if (ret == 0) {
+				keyGetString(genericKey,buffer,sizeof(buffer));
+				device->dev_chiprev=strtol(buffer, NULL, 10);
+			}
+			keyClose(genericKey);
+
+
+			
+
+			/* Get Clocks */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"Clocks",genericKey);
+			if (ret == 0) {
+				int i;
+				char *clock=NULL;
+				char *clockEnd=buffer;
+				
+				for (i = 0; i < CONF_MAXCLOCKS; i++)
+					device->dev_clock[i] = 0;
+				
+				
+				dataSize=keyGetDataSize(genericKey);
+				keyGetString(genericKey,buffer,dataSize);
+				
+				i=0;
+				do {
+					clock=clockEnd;
+					device->dev_clock[i] =
+						(int) (strtod(clock,&clockEnd) * 1000.0 + 0.5);
+				} while (i<CONF_MAXCLOCKS && clock!=clockEnd);
+			}
+			keyClose(genericKey);
+			
+
+			
+			
+			
+			/* Get TextClockFreq */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"TextClockFreq",genericKey);
+			if (ret == 0) {
+				keyGetString(genericKey,buffer,sizeof(buffer));
+				device->dev_textclockfreq=
+					(int) (strtod(buffer, NULL) * 1000.0 + 0.5);
+			}
+			keyClose(genericKey);
+
+			
+
+			
+			
+
+			/* Get BusID */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"BusID",genericKey);
+			if (ret == 0) {
+				dataSize=keyGetDataSize(genericKey);
+				device->dev_busid=xf86confmalloc(dataSize);
+				keyGetString(genericKey,device->dev_busid,dataSize);
+			}
+			keyClose(genericKey);
+			
+			
+			
+			/* Get IRQ */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"IRQ",genericKey);
+			if (ret == 0) {
+				keyGetString(genericKey,buffer,sizeof(buffer));
+				device->dev_irq=strtol(buffer, NULL, 10);
+			}
+			keyClose(genericKey);
+			
+
+			
+			/* Get Screen */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(current,"Screen",genericKey);
+			if (ret == 0) {
+				keyGetString(genericKey,buffer,sizeof(buffer));
+				device->dev_screen=strtol(buffer, NULL, 10);
+			}
+			keyDel(genericKey);
+			
+
+			
+			/* Now get this device's options */
+			dataSize=keyGetFullNameSize(current)+30;
+			options=xf86confmalloc(dataSize);
+			keyGetFullName(current,options,dataSize);
+			strcat(options,"/Options");
+
+			optionKeys = ksNew();
+			kdbGetChildKeys(options,optionKeys,KDB_O_SORT);
+			if (ksGetSize(optionKeys))
+				device->dev_option_lst=ksToOptions(optionKeys);
+			xf86conffree (options);
+			ksDel(optionKeys);
+
+			/* Finished with this device. Now add to our devices list */
+			if (ptr) ptr=(XF86ConfDevicePtr)
+				xf86addListItem ((glp) ptr, (glp) device);
+			else  ptr=device;
+		}
+	}
+	ksDel(devices);
+
+
+#ifdef DEBUG
+	printf ("Device keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+/*
+ * Elektra version of Device.c::xf86printDeviceSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfDevicePtr struct
+ * plus a root key name.
+ *
+ */
+void
+xf86addDevice (KeySet *ks, const char *root, XF86ConfDevicePtr ptr) {
+	char buffer[300];
+	char devroot[300];
+	Key *key;
+
+	while (ptr) {
+		sprintf(devroot,"%s/Devices/%s",root,ptr->dev_identifier);
+
+		if (ptr->dev_driver) {
+			sprintf(buffer,"%s/%s",devroot,"Driver");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_driver,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_vendor) {
+			sprintf(buffer,"%s/%s",devroot,"VendorName");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_vendor,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+
+		if (ptr->dev_board) {
+			sprintf(buffer,"%s/%s",devroot,"BoardName");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_board,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_chipset) {
+			sprintf(buffer,"%s/%s",devroot,"ChipSet");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_chipset,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_card) {
+			sprintf(buffer,"%s/%s",devroot,"Card");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_card,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_ramdac) {
+			sprintf(buffer,"%s/%s",devroot,"RamDac");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_ramdac,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_dacSpeeds[0] > 0 ) {
+			int i;
+
+			sprintf(buffer,"%s/%s",devroot,"DacSpeed");
+			key = keyNew(buffer, KEY_SWITCH_END);
+
+			buffer[0]=0;
+			for (i = 0; i < CONF_MAXDACSPEEDS
+					&& ptr->dev_dacSpeeds[i] > 0; i++ ) {
+				char num[30];
+				sprintf(num,"%g ", (double) (ptr->dev_dacSpeeds[i])/ 1000.0 );
+				strcat(buffer,num);
+			}
+
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_videoram) {
+			sprintf(buffer,"%s/%s",devroot,"VideoRam");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"%d",ptr->dev_videoram);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_bios_base) {
+			sprintf(buffer,"%s/%s",devroot,"BiosBase");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"0x%lx",ptr->dev_bios_base);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_mem_base) {
+			sprintf(buffer,"%s/%s",devroot,"MemBase");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"0x%lx",ptr->dev_mem_base);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_io_base) {
+			sprintf(buffer,"%s/%s",devroot,"IOBase");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"0x%lx",ptr->dev_io_base);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_clockchip) {
+			sprintf(buffer,"%s/%s",devroot,"ClockChip");
+			key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, ptr->dev_clockchip,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_chipid != -1) {
+			sprintf(buffer,"%s/%s",devroot,"ChipId");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"0x%x",ptr->dev_chipid);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_chiprev != -1) {
+			sprintf(buffer,"%s/%s",devroot,"ChipRev");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"0x%x",ptr->dev_chiprev);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_clocks > 0 ) {
+			int i;
+
+			sprintf(buffer,"%s/%s",devroot,"Clocks");
+			key = keyNew(buffer, KEY_SWITCH_END);
+
+			buffer[0]=0;
+			for (i = 0; i < ptr->dev_clocks; i++ ) {
+				char num[30];
+				sprintf (num, "%.1f ", (double)ptr->dev_clock[i] / 1000.0 );
+				strcat(buffer,num);
+			}
+			keySetString(key,buffer);
+		}
+
+		if (ptr->dev_textclockfreq) {
+			sprintf(buffer,"%s/%s",devroot,"TextClockFreq");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"%.1f",(double)ptr->dev_textclockfreq / 1000.0);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+
+		if (ptr->dev_busid) {
+			sprintf(buffer,"%s/%s",devroot,"BusID");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			keySetString(key,ptr->dev_busid);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_screen > 0) {
+			sprintf(buffer,"%s/%s",devroot,"Screen");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"%d",ptr->dev_screen);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_irq >= 0) {
+			sprintf(buffer,"%s/%s",devroot,"IRQ");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"%d",ptr->dev_irq);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		sprintf(buffer,"%s/Options",devroot);
+		xf86addOptions(ks, buffer, ptr->dev_option_lst);
+
+		ptr=ptr->list.next;
+	}
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Together with xf86getModes(), is the Elektra version of
+ * the Monitor.c::xf86parseVerboseMode() function.
+ *
+ * Converts a KeySet into a XF86ConfModeLinePtr struct.
+ *
+ */
+XF86ConfModeLinePtr
+ksToModes(KeySet *ks)
+{
+	Key *key;
+	XF86ConfModeLinePtr mode=NULL;
+	XF86ConfModeLinePtr modes=NULL; /* we'll return this */
+
+	ksRewind(ks);
+	while ((key=ksNext(ks))) {
+		Key *subKey;
+		size_t dataSize;
+		int ret;
+		char buffer[100]; /* a big enough buffer */
+
+		/* initialize an object */
+		mode=xf86confcalloc(1,sizeof(XF86ConfModeLineRec));
+		memset(mode,0,sizeof(XF86ConfModeLineRec));
+
+		/* calculate identifier from key basename */
+		dataSize=keyGetBaseNameSize(key);
+		mode->ml_identifier=xf86confmalloc(dataSize);
+		keyGetBaseName(key,mode->ml_identifier,dataSize);
+
+		/* Get DotClock */
+		subKey = keyNew(KEY_SWITCH_END);
+		ret=kdbGetKeyByParentKey(key,"DotClock",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			mode->ml_clock=(int)(strtod(buffer,NULL) * 1000.0 + 0.5);
+		}
+		keyClose(subKey);
+
+
+
+		/* Get HTimings' hdisplay */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"HTimings.hdisp",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			mode->ml_hdisplay=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+		/* Get HTimings' hsyncstart */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"HTimings.hsyncstart",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			mode->ml_hsyncstart=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+		/* Get HTimings' hsyncend */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"HTimings.hsyncend",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			mode->ml_hsyncend=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+		/* Get HTimings' htotal */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"HTimings.htotal",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			mode->ml_htotal=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+
+
+		/* Get VTimings' vdisplay */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"VTimings.vdisp",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			mode->ml_vdisplay=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+		/* Get VTimings' vsyncstart */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"VTimings.vsyncstart",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			mode->ml_vsyncstart=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+		/* Get VTimings' vsyncend */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"VTimings.vsyncend",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			mode->ml_vsyncend=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+		/* Get VTimings' vtotal */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"VTimings.vtotal",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			mode->ml_vtotal=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get Flag Interlace */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Flag.interlace",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			if (strtol(buffer,NULL,10) != 0)
+				mode->ml_flags |= XF86CONF_INTERLACE;
+		}
+		keyClose(subKey);
+
+
+		/* Get Flag hsync */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Flag.hsync",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			switch (strtol(buffer,NULL,10)) {
+				case -1:
+					mode->ml_flags |= XF86CONF_NHSYNC;
+					break;
+				case 1:
+					mode->ml_flags |= XF86CONF_PHSYNC;
+					break;
+			}
+		}
+		keyClose(subKey);
+
+
+		/* Get Flag vsync */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Flag.vsync",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			switch (strtol(buffer,NULL,10)) {
+				case -1:
+					mode->ml_flags |= XF86CONF_NVSYNC;
+					break;
+				case 1:
+					mode->ml_flags |= XF86CONF_PVSYNC;
+					break;
+			}
+		}
+		keyClose(subKey);
+
+
+		/* Get Flag Composite */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Flag.composite",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			if (strtol(buffer,NULL,10) != 0)
+				mode->ml_flags |= XF86CONF_CSYNC;
+		}
+		keyClose(subKey);
+
+
+		/* Get Flag csync */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Flag.csync",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			switch (strtol(buffer,NULL,10)) {
+				case -1:
+					mode->ml_flags |= XF86CONF_NCSYNC;
+					break;
+				case 1:
+					mode->ml_flags |= XF86CONF_PCSYNC;
+					break;
+			}
+		}
+		keyClose(subKey);
+
+
+		/* Get Flag DoubleScan */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Flag.doublescan",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			if (strtol(buffer,NULL,10) != 0)
+				mode->ml_flags |= XF86CONF_DBLSCAN;
+		}
+		keyClose(subKey);
+		
+
+		/* Get Flag BCast */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Flag.bcast",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			if (strtol(buffer,NULL,10) != 0)
+				mode->ml_flags |= XF86CONF_BCAST;
+		}
+		keyClose(subKey);
+
+		
+		/* Get HSkew */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"HSkew",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			mode->ml_hskew=strtol(buffer,NULL,10);
+			mode->ml_flags |= XF86CONF_HSKEW;
+		}
+		keyClose(subKey);
+
+
+		/* Get VScan */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"VScan",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			mode->ml_vscan=strtol(buffer,NULL,10);
+			mode->ml_flags |= XF86CONF_VSCAN;
+		}
+		keyClose(subKey);
+
+		
+		/* Get Custom ???? */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Custom",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			if (strtol(buffer,NULL,10) != 0)
+				mode->ml_flags |= XF86CONF_CUSTOM;
+		}
+		keyDel(subKey);
+
+
+		modes=((XF86ConfModeLinePtr)xf86addListItem((glp)modes,
+			(glp)mode));
+	}
+#ifdef DEBUG
+	printf ("Mode keys grabed\n");
+#endif
+	return modes;
+}
+
+
+/*
+ * Together with ksToModes(), is the Elektra version for
+ * the Monitor.c::xf86parseVerboseMode() function.
+ *
+ * Fetches keys under [rootKey]/Modes.
+ *
+ */
+XF86ConfModesPtr
+xf86getModes (const char *rootKey)
+{
+	XF86ConfModesPtr modes=NULL; /* we'll return this */
+	KeySet *ksModes;
+	Key *kMode;
+	char modesRoot[sizeof(rootKey)+50];
+
+	ksModes = ksNew();
+
+	strcpy(modesRoot,rootKey);
+	strcat(modesRoot,"/Modes");
+
+	kdbGetChildKeys(modesRoot,ksModes,
+		KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+
+	while ((kMode=ksNext(ksModes))) {
+		size_t size;
+		KeySet *realModes;
+
+		/* ptr is declared here */
+		parsePrologue(XF86ConfModesPtr, XF86ConfModesRec)
+
+		/* Put a name in this new Mode */
+		size=keyGetBaseNameSize(kMode);
+		ptr->modes_identifier=xf86confmalloc(size);
+		keyGetBaseName(kMode,ptr->modes_identifier,size);
+
+		realModes = ksNew();
+
+		/* Get the real modelines below it */
+		keyGetName(kMode,modesRoot,sizeof(modesRoot));
+		kdbGetChildKeys(modesRoot,realModes,
+			KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+
+		if (ksGetSize(realModes)) {
+			ptr->mon_modeline_lst=(XF86ConfModeLinePtr)
+				xf86addListItem ((glp) ptr->mon_modeline_lst,
+					(glp) ksToModes(realModes));
+		}
+
+		ksDel(realModes);
+
+		if (modes)
+			modes=(XF86ConfModesPtr)xf86addListItem((glp)modes,(glp)ptr);
+		else modes=ptr;
+	}
+
+	ksDel(ksModes);
+
+	return modes;
+}
+
+
+/*
+ * Helper to generate a KeySet from a passed linked list of
+ * XF86ConfModeLinePtr struct plus a root key name. This function is called
+ * by xf86addModes() bellow.
+ * 
+ */
+void
+xf86addModelines(KeySet *ks, const char *root, XF86ConfModeLinePtr ptr)
+{
+	XF86ConfModeLinePtr mlptr;
+	Key *key;
+	char buffer[300];
+	
+	for (mlptr = ptr; mlptr; mlptr = mlptr->list.next) {
+		char moderoot[300];
+		sprintf(moderoot,"%s/%s",root,mlptr->ml_identifier);
+
+		sprintf(buffer,"%s/%s",moderoot,"DotClock");
+		key = keyNew(buffer, KEY_SWITCH_END);
+		sprintf(buffer,"%2.1f",mlptr->ml_clock / 1000.0);
+		keySetString(key,buffer);
+		ksAppend(ks,key);
+
+		sprintf(buffer,"%s/%s",moderoot,"HTimings.hdisp");
+		key = keyNew(buffer, KEY_SWITCH_END);
+		sprintf(buffer,"%d", mlptr->ml_hdisplay);
+		keySetString(key,buffer);
+		ksAppend(ks,key);
+		
+		sprintf(buffer,"%s/%s",moderoot,"HTimings.hsyncstart");
+		key = keyNew(buffer, KEY_SWITCH_END);
+		sprintf(buffer,"%d", mlptr->ml_hsyncstart);
+		keySetString(key,buffer);
+		ksAppend(ks,key);
+		
+		sprintf(buffer,"%s/%s",moderoot,"HTimings.hsyncend");
+		key = keyNew(buffer, KEY_SWITCH_END);
+		sprintf(buffer,"%d", mlptr->ml_hsyncend);
+		keySetString(key,buffer);
+		ksAppend(ks,key);
+		
+		sprintf(buffer,"%s/%s",moderoot,"HTimings.htotal");
+		key = keyNew(buffer, KEY_SWITCH_END);
+		sprintf(buffer,"%d", mlptr->ml_htotal);
+		keySetString(key,buffer);
+		ksAppend(ks,key);
+		
+		sprintf(buffer,"%s/%s",moderoot,"VTimings.vdisp");
+		key = keyNew(buffer, KEY_SWITCH_END);
+		sprintf(buffer,"%d", mlptr->ml_vdisplay);
+		keySetString(key,buffer);
+		ksAppend(ks,key);
+
+		sprintf(buffer,"%s/%s",moderoot,"VTimings.vsyncstart");
+		key = keyNew(buffer, KEY_SWITCH_END);
+		sprintf(buffer,"%d", mlptr->ml_vsyncstart);
+		keySetString(key,buffer);
+		ksAppend(ks,key);
+		
+		sprintf(buffer,"%s/%s",moderoot,"VTimings.vsyncend");
+		key = keyNew(buffer, KEY_SWITCH_END);
+		sprintf(buffer,"%d", mlptr->ml_vsyncend);
+		keySetString(key,buffer);
+		ksAppend(ks,key);
+			
+		sprintf(buffer,"%s/%s",moderoot,"VTimings.vtotal");
+		key = keyNew(buffer, KEY_SWITCH_END);
+		sprintf(buffer,"%d", mlptr->ml_vtotal);
+		keySetString(key,buffer);
+		ksAppend(ks,key);
+			
+			
+		if (mlptr->ml_flags & XF86CONF_PHSYNC) {
+			sprintf(buffer,"%s/%s",moderoot,"Flag.hsync");
+			key = keyNew(buffer, 
+					KEY_SWITCH_VALUE,	"1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_NHSYNC) {
+			sprintf(buffer,"%s/%s",moderoot,"Flag.hsync");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "-1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_PVSYNC) {
+			sprintf(buffer,"%s/%s",moderoot,"Flag.vsync");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_NVSYNC) {
+			sprintf(buffer,"%s/%s",moderoot,"Flag.vsync");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "-1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_INTERLACE) {
+			sprintf(buffer,"%s/%s",moderoot,"Flag.interlace");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_CSYNC) {
+			sprintf(buffer,"%s/%s",moderoot,"Flag.composite");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_PCSYNC) {
+			sprintf(buffer,"%s/%s",moderoot,"Flag.csync");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_NCSYNC) {
+			sprintf(buffer,"%s/%s",moderoot,"Flag.csync");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "-1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_DBLSCAN) {
+			sprintf(buffer,"%s/%s",moderoot,"Flag.doublescan");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_HSKEW) {
+			sprintf(buffer,"%s/%s",moderoot,"HSkew");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"%d", mlptr->ml_hskew);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_BCAST) {
+			sprintf(buffer,"%s/%s",moderoot,"Flag.bcast");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_VSCAN) {
+			sprintf(buffer,"%s/%s",moderoot,"Flag.vscan");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+	} /* end "for" loop: mode processing */
+
+}
+
+
+/*
+ * Elektra version of Monitor.c::xf86printModesSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfModesPtr struct
+ * plus a root key name. It wraps a call to xf86addModelines() to generate
+ * the Modelines.
+ * 
+ */
+void
+xf86addModes(KeySet *ks, const char *root, XF86ConfModesPtr ptr)
+{
+	char modeRoot[300];
+	int modeIndex=0;
+	
+	
+	while (ptr) {
+		if (! ptr->modes_identifier) {
+			++modeIndex;
+			sprintf(modeRoot,"%s/Modes/mode%02d",root,modeIndex);
+		} else sprintf(modeRoot,"%s/Modes/%s",root,ptr->modes_identifier);
+		
+		xf86addModelines(ks, modeRoot, ptr->mon_modeline_lst);
+		ptr=ptr->list.next;
+	}
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#undef CLEANUP
+#define CLEANUP xf86freeMonitorList
+
+
+/*
+ * Elektra version for the Monitor.c::xf86parseMonitorSection() function
+ *
+ * Fetch keys under [rootKey]/Monitors
+ * All monitors are there.
+ *
+ * TODO: check int and float conversions
+ *
+ */
+XF86ConfMonitorPtr
+xf86getMonitor (const char *rootKey)
+{
+	KeySet *monitors;
+	Key *current;
+	int ret;
+	char localRootKey[sizeof(rootKey)+50];
+
+	XF86ConfMonitorPtr ptr = NULL;
+
+	strcpy(localRootKey,rootKey);
+	strcat(localRootKey,"/Monitors");
+
+	monitors = ksNew();
+	/*
+	 * There should be only folders right under Monitors/.
+	 * So we are interested only in the skeleton.
+	 */
+	kdbGetChildKeys(localRootKey, monitors,
+		KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+
+
+	if (ksGetSize(monitors) == 0) {
+		ksDel(monitors);
+		return NULL;
+	}
+
+	ksRewind(monitors);
+	while ((current=ksNext(monitors))) {
+		/* each entry we'll process is a Monitor */
+		XF86ConfMonitorPtr monitor;
+		KeySet *optionKeys;
+		Key *genericKey;
+		size_t identSize,dataSize;
+		char *options=NULL;
+		char buffer[100];
+
+
+		monitor=xf86confcalloc(1,sizeof(XF86ConfMonitorRec));
+		memset(monitor,0,sizeof(XF86ConfMonitorRec));
+
+		identSize=keyGetBaseNameSize(current);
+		monitor->mon_identifier=xf86confmalloc(identSize);
+		if (monitor->mon_identifier)
+			keyGetBaseName(current,monitor->mon_identifier,identSize);
+
+
+		/* Get Vendor */
+		genericKey = keyNew(KEY_SWITCH_END);
+		ret=kdbGetKeyByParentKey(current,"VendorName",genericKey);
+		if (ret == 0) {
+			dataSize=keyGetDataSize(genericKey);
+			monitor->mon_vendor=xf86confmalloc(dataSize);
+			keyGetString(genericKey,monitor->mon_vendor,dataSize);
+		}
+		keyClose(genericKey);
+
+
+
+
+		/* Get ModelName */
+		keyInit(genericKey);
+		ret=kdbGetKeyByParentKey(current,"ModelName",genericKey);
+		if (ret == 0) {
+			dataSize=keyGetDataSize(genericKey);
+			monitor->mon_modelname=xf86confmalloc(dataSize);
+			keyGetString(genericKey,monitor->mon_modelname,dataSize);
+		}
+		keyClose(genericKey);
+
+
+
+
+		/* Get DisplaySizeWidth */
+		keyInit(genericKey);
+		ret=kdbGetKeyByParentKey(current,"DisplaySize.width",genericKey);
+		if (ret == 0) {
+			keyGetString(genericKey,buffer,sizeof(buffer));
+			monitor->mon_width=strtod(buffer, NULL);
+		}
+		keyClose(genericKey);
+
+		/* Get DisplaySizeHeight */
+		keyInit(genericKey);
+		ret=kdbGetKeyByParentKey(current,"DisplaySize.height",genericKey);
+		if (ret == 0) {
+			keyGetString(genericKey,buffer,sizeof(buffer));
+			monitor->mon_height=strtod(buffer, NULL);
+		}
+		keyClose(genericKey);
+
+
+
+
+
+		/* Get UseModes, a CSV of mode names */
+		keyInit(genericKey);
+		ret=kdbGetKeyByParentKey(current,"UseModes",genericKey);
+		if (ret == 0) {
+			char *modes, *cursor, *cursorEnd;
+
+			dataSize=keyGetDataSize(genericKey);
+			modes=xf86confmalloc(dataSize);
+			keyGetString(genericKey,modes,dataSize);
+
+			cursor=modes;
+			do {
+				XF86ConfModesLinkPtr mptr;
+
+				cursorEnd=index(cursor,',');
+				if (cursorEnd) {
+					*cursorEnd=0;
+					cursorEnd++;
+				}
+
+				mptr = xf86confcalloc (1, sizeof (XF86ConfModesLinkRec));
+				mptr->list.next = NULL;
+				mptr->ml_modes_str = xf86confmalloc(strlen(cursor)+1);
+				strcpy(mptr->ml_modes_str,cursor);
+				mptr->ml_modes = NULL;
+
+				monitor->mon_modes_sect_lst = (XF86ConfModesLinkPtr)
+				xf86addListItem((GenericListPtr)monitor->mon_modes_sect_lst,
+					    (GenericListPtr)mptr);
+
+				cursor=cursorEnd;
+			} while (cursor);
+
+			xf86conffree(modes);
+		}
+		keyClose(genericKey);
+
+
+
+
+		/* Get Gamma */
+		keyInit(genericKey);
+		ret=kdbGetKeyByParentKey(current,"Gamma",genericKey);
+		if (ret == 0) {
+			keyGetString(genericKey,buffer,sizeof(buffer));
+			monitor->mon_gamma_green=monitor->mon_gamma_blue=
+			monitor->mon_gamma_red=strtod(buffer, NULL);
+		}
+		keyClose(genericKey);
+
+
+		/* Get GammaRed */
+		keyInit(genericKey);
+		ret=kdbGetKeyByParentKey(current,"Gamma.red",genericKey);
+		if (ret == 0) {
+			keyGetString(genericKey,buffer,sizeof(buffer));
+			monitor->mon_gamma_red=strtod(buffer, NULL);
+		}
+		keyClose(genericKey);
+
+
+		/* Get GammaGreen */
+		keyInit(genericKey);
+		ret=kdbGetKeyByParentKey(current,"Gamma.green",genericKey);
+		if (ret == 0) {
+			keyGetString(genericKey,buffer,sizeof(buffer));
+			monitor->mon_gamma_green=strtod(buffer, NULL);
+		}
+		keyClose(genericKey);
+
+
+		/* Get GammaBlue */
+		keyInit(genericKey);
+		ret=kdbGetKeyByParentKey(current,"Gamma.blue",genericKey);
+		if (ret == 0) {
+			keyGetString(genericKey,buffer,sizeof(buffer));
+			monitor->mon_gamma_blue=strtod(buffer, NULL);
+		}
+		keyClose(genericKey);
+
+
+
+
+
+		/* Get HorizSync, a CSV of ranges */
+		keyInit(genericKey);
+		ret=kdbGetKeyByParentKey(current,"HorizSync",genericKey);
+		if (ret == 0) {
+			/* parse a string like "num1-num2,num3-num4,num5-num6" */
+
+			char *csv, *cursor, *cursorEnd;
+
+			dataSize=keyGetDataSize(genericKey);
+			csv=xf86confmalloc(dataSize);
+			keyGetString(genericKey,csv,dataSize);
+
+			cursor=csv;
+			do {
+				char *dash=cursor;
+
+				cursorEnd=index(cursor,',');
+				if (cursorEnd) {
+					*cursorEnd=0;
+					cursorEnd++;
+				}
+
+				dash=index(cursor,'-');
+				if (dash) {
+					*dash=0;
+					dash++;
+				}
+
+				monitor->mon_hsync[monitor->mon_n_hsync].hi=
+					monitor->mon_hsync[monitor->mon_n_hsync].lo=
+					strtod(cursor, NULL);
+
+				if (dash) {
+					monitor->mon_hsync[monitor->mon_n_hsync].hi=
+					strtod(dash, NULL);
+
+					if (monitor->mon_hsync[monitor->mon_n_hsync].hi<
+						monitor->mon_hsync[monitor->mon_n_hsync].lo) {
+						Error (HORIZSYNC_MSG, NULL);
+
+						monitor->mon_hsync[monitor->mon_n_hsync].hi=
+						monitor->mon_hsync[monitor->mon_n_hsync].lo;
+					}
+				}
+
+				cursor=cursorEnd;
+				if (monitor->mon_n_hsync >= CONF_MAX_HSYNC) {
+					Error ("Sorry. Too many horizontal sync intervals.",
+						NULL);
+					cursor=NULL;
+				} else monitor->mon_n_hsync++;
+			} while (cursor);
+			
+			xf86conffree(csv);
+		}
+		keyClose(genericKey);
+		
+		
+		
+		/* Get VertRefresh, a CSV of ranges */
+		keyInit(genericKey);
+		ret=kdbGetKeyByParentKey(current,"VertRefresh",genericKey);
+		if (ret == 0) {
+			/* parse a string like "num1-num2,num3-num4,num5-num6" */
+		
+			char *csv, *cursor, *cursorEnd;
+
+			dataSize=keyGetDataSize(genericKey);
+			csv=xf86confmalloc(dataSize);
+			keyGetString(genericKey,csv,dataSize);
+			
+			cursor=csv;
+			do {
+				char *dash=cursor;
+
+				cursorEnd=index(cursor,',');
+				if (cursorEnd) {
+					*cursorEnd=0;
+					cursorEnd++;
+				}
+
+				dash=index(cursor,'-');
+				if (dash) {
+					*dash=0;
+					dash++;
+				}
+
+				monitor->mon_vrefresh[monitor->mon_n_vrefresh].hi=
+					monitor->mon_vrefresh[monitor->mon_n_vrefresh].lo=
+					strtod(cursor, NULL);
+
+				if (dash) {
+					monitor->mon_vrefresh[monitor->mon_n_vrefresh].hi=
+					strtod(dash, NULL);
+				
+					if (monitor->mon_vrefresh[monitor->mon_n_vrefresh].hi<
+						monitor->mon_vrefresh[monitor->mon_n_vrefresh].lo) {
+						Error (VERTREFRESH_MSG, NULL);
+						
+						monitor->mon_vrefresh[monitor->mon_n_vrefresh].hi=
+						monitor->mon_vrefresh[monitor->mon_n_vrefresh].lo;
+					}
+				}
+			
+				cursor=cursorEnd;
+				if (monitor->mon_n_vrefresh >= CONF_MAX_VREFRESH) {
+					Error ("Sorry. Too many vertical refresh intervals.",
+						NULL);
+					cursor=NULL;
+				} else monitor->mon_n_vrefresh++;
+			} while (cursor);
+			
+			xf86conffree(csv);
+		}
+		keyDel(genericKey);
+		
+
+
+		/* Get monitor Modes */
+		dataSize=keyGetFullNameSize(current)+30;
+		options=xf86confmalloc(dataSize);
+		keyGetFullName(current,options,dataSize);
+		strcat(options,"/Modes");
+		
+		optionKeys = ksNew();
+		kdbGetChildKeys(options,optionKeys,
+			KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+		if (ksGetSize(optionKeys))
+			monitor->mon_modeline_lst=ksToModes(optionKeys);
+		xf86conffree (options);
+		ksClose(optionKeys);
+
+
+
+
+		/* Now get this monitor's options */
+		dataSize=keyGetFullNameSize(current)+30;
+		options=xf86confmalloc(dataSize);
+		keyGetFullName(current,options,dataSize);
+		strcat(options,"/Options");
+
+		ksInit(optionKeys);
+		kdbGetChildKeys(options,optionKeys,KDB_O_SORT);
+		if (ksGetSize(optionKeys))
+			monitor->mon_option_lst=ksToOptions(optionKeys);
+		xf86conffree (options);
+		ksClose(optionKeys);
+
+		/* Finished with this device. Now add to our devices list */
+		if (ptr) ptr=(XF86ConfMonitorPtr)
+			xf86addListItem ((glp) ptr, (glp) monitor);
+		else  ptr=monitor;
+	}
+
+	ksDel(monitors);
+
+
+#ifdef DEBUG
+	printf ("Monitor keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+/*
+ * Elektra version of Monitor.c::xf86printMonitorSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfMonitorPtr struct
+ * plus a root key name.
+ * 
+ */
+void
+xf86addMonitor (KeySet *ks, const char *root, XF86ConfMonitorPtr ptr) {
+	char buffer[300];
+	char devroot[300];
+	Key *key;
+	int i;
+	XF86ConfModesLinkPtr mptr;
+
+	while (ptr) {
+		sprintf(devroot,"%s/Monitors/%s",root,ptr->mon_identifier);
+
+		if (ptr->mon_vendor) {
+			sprintf(buffer,"%s/%s",devroot,"VendorName");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->mon_vendor,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->mon_modelname) {
+			sprintf(buffer,"%s/%s",devroot,"ModelName");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->mon_modelname,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if ((mptr = ptr->mon_modes_sect_lst)) {
+			sprintf(buffer,"%s/%s",devroot,"UseModes");
+			key = keyNew(buffer, KEY_SWITCH_END);
+
+			buffer[0]=0;
+			while (mptr) {
+				if (buffer[0] != 0) strcat(buffer,",");
+				strcat (buffer,mptr->ml_modes_str);
+				mptr = mptr->list.next;
+			}
+			
+			keySetString(key,buffer);
+			keySetComment(key,
+				"A comma separated list of modes, without spaces");
+			ksAppend(ks,key);
+		}
+			
+		if (ptr->mon_width) {
+			sprintf(buffer,"%s/%s",devroot,"DisplaySize.width");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"%d",ptr->mon_width);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+			
+			sprintf(buffer,"%s/%s",devroot,"DisplaySize.height");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"%d",ptr->mon_height);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->mon_n_hsync > 0) {
+			sprintf(buffer,"%s/%s",devroot,"HorizSync");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			
+			buffer[0]=0;
+			for (i = 0; i < ptr->mon_n_hsync; i++) {
+				char range[50];
+
+				if (buffer[0]) strcat(buffer,", ");
+				sprintf(range,"%2.1f - %2.1f",
+					 ptr->mon_hsync[i].lo,
+					 ptr->mon_hsync[i].hi);
+
+				strcat(buffer,range);
+			}
+
+			keySetString(key,buffer);
+			keySetComment(key,"Ex: 30.0-61.0, 70-83.2");
+			ksAppend(ks,key);
+		}
+
+		if (ptr->mon_n_vrefresh > 0) {
+			sprintf(buffer,"%s/%s",devroot,"VertRefresh");
+			key = keyNew(buffer, KEY_SWITCH_END);
+
+			buffer[0]=0;
+			for (i = 0; i < ptr->mon_n_vrefresh; i++) {
+				char range[50];
+				
+				if (buffer[0]) strcat(buffer,", ");
+				sprintf(range,"%2.1f - %2.1f",
+					 ptr->mon_vrefresh[i].lo,
+					 ptr->mon_vrefresh[i].hi);
+
+				strcat(buffer,range);
+			}
+			
+			keySetString(key,buffer);
+			keySetComment(key,"Ex: 30.0-61.0, 70-83.2");
+			ksAppend(ks,key);
+		}
+
+		if (ptr->mon_gamma_red) {
+			if (ptr->mon_gamma_red == ptr->mon_gamma_green
+				&& ptr->mon_gamma_red == ptr->mon_gamma_blue) {
+				sprintf(buffer,"%s/%s",devroot,"Gamma");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%.4g",ptr->mon_gamma_red);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+			} else {
+				sprintf(buffer,"%s/%s",devroot,"Gamma.red");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%.4g",ptr->mon_gamma_red);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+				
+				sprintf(buffer,"%s/%s",devroot,"Gamma.green");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%.4g",ptr->mon_gamma_green);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+				
+				sprintf(buffer,"%s/%s",devroot,"Gamma.blue");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%.4g",ptr->mon_gamma_blue);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+			}
+		}
+		
+		
+		sprintf(buffer,"%s/Modes",devroot);
+		xf86addModelines(ks,buffer,ptr->mon_modeline_lst);
+		
+		sprintf(buffer,"%s/Options",devroot);
+		xf86addOptions(ks, buffer, ptr->mon_option_lst);
+		ptr = ptr->list.next;
+	} /* end "while" loop: single monitor processing */
+}
+
+
+
+
+
+
+
+
+
+#undef CLEANUP
+#define CLEANUP xf86freeDRI
+
+
+/*
+ * Elektra version for the DRI.c::xf86parseDRISection() function
+ *
+ * Fetch keys under [rootKey]/DRI .
+ *
+ */
+XF86ConfDRIPtr
+xf86getDRI (const char *rootKey)
+{
+	Key *key;
+	int ret;
+	char buffer[200];
+	char parent[200];
+	size_t size;
+	int hasDRI=0;
+
+	parsePrologue (XF86ConfDRIPtr, XF86ConfDRIRec);
+
+	ptr->dri_group=-1;
+
+	strcpy(parent,rootKey);
+	strcat(parent,"/DRI");
+
+	key = keyNew(KEY_SWITCH_END);
+	ret=kdbGetKeyByParent(parent,"Group",key);
+	if (ret == 0) {
+		long group;
+		char *endptr;
+
+		size=keyGetDataSize(key);
+		keyGetString(key,buffer,size);
+		group=strtol(buffer,&endptr,10);
+		if (endptr!=buffer) ptr->dri_group=group;
+		else { /* not a number */
+			ptr->dri_group_name=xf86confmalloc(size);
+			strcpy(ptr->dri_group_name,buffer);
+		}
+		hasDRI=1;
+	}
+	keyClose(key);
+
+	keyInit(key);
+	ret=kdbGetKeyByParent(parent,"Mode",key);
+	if (ret == 0) {
+		size=keyGetDataSize(key);
+		keyGetString(key,buffer,size);
+		ptr->dri_mode=strtol(buffer,NULL,0);
+		hasDRI=1;
+	}
+	keyClose(key);
+
+	keyInit(key);
+	ret=kdbGetKeyByParent(parent,"Buffers",key);
+	if (ret == 0) {
+		char *cursor,*numEnd,*cursorEnd;
+
+		size=keyGetDataSize(key);
+		keyGetString(key,buffer,size);
+
+		cursor=buffer;
+		do {
+			XF86ConfBuffersPtr buf;
+			buf=xf86confmalloc(sizeof(XF86ConfBuffersRec));
+			memset(buf,0,sizeof(XF86ConfBuffersRec));
+
+			cursorEnd=index(cursor,',');
+			if (cursorEnd) {
+				*cursorEnd=0;
+				++cursorEnd;
+			}
+
+			buf->buf_count=strtol(cursor,&numEnd,10);
+			cursor=numEnd;
+			buf->buf_size=strtol(cursor,&numEnd,10);
+			cursor=numEnd;
+			
+			if ((size=strlen(cursor))) {
+				/* seems we have flags */
+				buf->buf_flags=xf86confmalloc(size+1);
+				strcpy(buf->buf_flags,cursor);
+			}
+			
+			/* Add this buffer to the list */
+			ptr->dri_buffers_lst=(XF86ConfBuffersPtr)
+				xf86addListItem((glp)ptr->dri_buffers_lst,(glp)buf);
+			cursor=cursorEnd;
+		} while (cursor);
+		hasDRI=1;
+	}
+	keyDel(key);
+
+	if (hasDRI == 0) {
+		CLEANUP(ptr);
+		ptr=NULL;
+	}
+	
+#ifdef DEBUG
+	ErrorF("DRI keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+
+/*
+ * Elektra version of DRI.c::xf86printDRISection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfDRIPtr struct
+ * plus a root key name.
+ * 
+ */
+void
+xf86addDRI(KeySet *ks, const char *root, XF86ConfDRIPtr ptr)
+{
+	XF86ConfBuffersPtr bufs=0;
+	char buffer[300];
+	Key *key;
+
+	if (ptr == NULL) return;
+
+	if (ptr->dri_group_name) {
+		sprintf(buffer,"%s/DRI/Group",root);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, ptr->dri_group_name,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+	} else if (ptr->dri_group >= 0) {
+		sprintf(buffer,"%s/DRI/Group",root);
+		key = keyNew(buffer, KEY_SWITCH_END);
+		sprintf(buffer,"%d",ptr->dri_group);
+		keySetString(key,buffer);
+		ksAppend(ks,key);
+	}
+
+	if (ptr->dri_mode) {
+		sprintf(buffer,"%s/DRI/Mode",root);
+		key = keyNew(buffer, KEY_SWITCH_END);
+		sprintf(buffer,"0%o",ptr->dri_mode);
+		keySetString(key,buffer);
+		ksAppend(ks,key);
+	}
+
+	if (bufs) {
+		sprintf(buffer,"%s/DRI/Buffers",root);
+		key = keyNew(buffer, KEY_SWITCH_END);
+		buffer[0]=0;
+		for (bufs = ptr->dri_buffers_lst; bufs; bufs = bufs->list.next) {
+			char bufbuf[100];
+			
+			if (*buffer) strcat(buffer,",");
+		
+			sprintf (bufbuf, "%d %d", bufs->buf_count, bufs->buf_size);
+			strcat(buffer,bufbuf);
+			
+			if (bufs->buf_flags) {
+				sprintf (bufbuf, " %s", bufs->buf_flags);
+				strcat(buffer,bufbuf);
+			}
+		}
+
+		keySetString(key,buffer);
+		ksAppend(ks,key);
+	}
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Screen.c::xf86parseDisplaySubSection() function.
+ *
+ * Helper wrapped by xf86getScreen() that generates a
+ * XF86ConfDisplayPtr struct from a KeySet.
+ *
+ * TODO: check int and float conversions
+ *
+ */
+XF86ConfDisplayPtr
+ksToDisplays(KeySet *ks)
+{
+	Key *key;
+	XF86ConfDisplayPtr ptr;
+	XF86ConfDisplayPtr displays=NULL; /* we'll return this */
+
+	ksRewind(ks);
+	while ((key=ksNext(ks))) {
+		KeySet *optionKeys;
+		char *options=NULL;
+		Key *subKey;
+		size_t dataSize;
+		int ret;
+		char buffer[100]; /* a big enough buffer */
+
+		/* initialize an object */
+		ptr=xf86confcalloc(1,sizeof(XF86ConfDisplayRec));
+		memset(ptr,0,sizeof(XF86ConfDisplayRec));
+
+		ptr->disp_black.red =
+		ptr->disp_black.green =
+		ptr->disp_black.blue =
+		ptr->disp_white.red =
+		ptr->disp_white.green =
+		ptr->disp_white.blue =
+		ptr->disp_frameX0 =
+		ptr->disp_frameY0 = -1;
+
+		/* Get Viewport.x */
+		subKey = keyNew(KEY_SWITCH_END);
+		ret=kdbGetKeyByParentKey(key,"Viewport.x",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_frameX0=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+		/* Get Viewport.y */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Viewport.y",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_frameY0=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get Virtual.x */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Virtual.x",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_virtualX=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+		/* Get Virtual.y */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Virtual.y",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_virtualY=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get Depth */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Depth",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_depth=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get FbBpp */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"FbBPP",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_bpp=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+		
+		/* Get Visual */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Visual",subKey);
+		if (ret == 0) {
+			dataSize=keyGetDataSize(subKey);
+			ptr->disp_visual=xf86confmalloc(dataSize);
+			keyGetString(subKey,ptr->disp_visual,dataSize);
+		}
+		keyClose(subKey);
+
+
+		/* Get Weight.red */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Weight.red",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_weight.red=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get Weight.green */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Weight.green",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_weight.green=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get Weight.blue */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Weight.blue",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_weight.blue=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get Black.red */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Black.red",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_black.red=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get Black.green */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Black.green",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_black.green=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get Black.blue */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Black.blue",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_black.blue=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get White.red */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"White.red",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_white.red=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get White.green */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"White.green",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_white.green=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get White.blue */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"White.blue",subKey);
+		if (ret == 0) {
+			keyGetString(subKey,buffer,sizeof(buffer));
+			ptr->disp_white.blue=strtol(buffer,NULL,10);
+		}
+		keyClose(subKey);
+
+
+		/* Get Modes */
+		keyInit(subKey);
+		ret=kdbGetKeyByParentKey(key,"Modes",subKey);
+		if (ret == 0) {
+			char *cursor,*cursorEnd;
+
+			keyGetString(subKey,buffer,sizeof(buffer));
+
+			cursor=buffer;
+			do {
+				XF86ModePtr mptr;
+
+				cursorEnd=index(cursor,',');
+				if (cursorEnd) {
+					*cursorEnd=0;
+					++cursorEnd;
+				}
+
+				mptr=xf86confmalloc(sizeof (XF86ModeRec));
+				mptr->mode_name=xf86confmalloc(strlen(cursor)+1);
+				strcpy(mptr->mode_name,cursor);
+				mptr->list.next=NULL;
+
+				ptr->disp_mode_lst = (XF86ModePtr)
+					xf86addListItem ((glp) ptr->disp_mode_lst, (glp) mptr);
+
+				cursor=cursorEnd;
+			} while (cursor);
+		}
+		keyDel(subKey);
+
+
+		/* Now get this display's options */
+		dataSize=keyGetFullNameSize(key)+30;
+		options=xf86confmalloc(dataSize);
+		keyGetFullName(key,options,dataSize);
+		strcat(options,"/Options");
+			
+		optionKeys = ksNew();
+		kdbGetChildKeys(options,optionKeys,KDB_O_SORT);
+		if (ksGetSize(optionKeys))
+			ptr->disp_option_lst=ksToOptions(optionKeys);
+		xf86conffree (options);
+		ksDel(optionKeys);
+		
+		/* Finished with this display. Now add to our displays list */
+		if (displays) ptr=(XF86ConfDisplayPtr)
+			xf86addListItem ((glp) displays, (glp) ptr);
+		else  displays=ptr;
+
+	}
+#ifdef DEBUG
+	printf ("Display subsection keys grabed\n");
+#endif
+
+	return displays;
+}
+
+
+/*
+ * Elektra version for the Screen.c::xf86parseScreenSection() function.
+ *
+ * Fetch keys under [rootKey]/Screens .
+ *
+ */
+XF86ConfScreenPtr
+xf86getScreen (const char *rootKey)
+{
+	XF86ConfScreenPtr ptr=NULL; /* we'll return this */
+	KeySet *screens;
+	Key *key;
+	char screensRoot[sizeof(rootKey)+30];
+	int ret;
+
+	screens = ksNew();
+
+	strcpy(screensRoot,rootKey);
+	strcat(screensRoot,"/Screens");
+
+	kdbGetChildKeys(screensRoot,screens,
+		KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+
+	if (ksGetSize(screens)) {
+		ksRewind(screens);
+		while ((key=ksNext(screens))) {
+			XF86ConfScreenPtr screen;
+			Key *genericKey;
+			KeySet *optionKeys;
+			char *options=NULL;
+			char buffer[200];
+			size_t dataSize;
+
+			screen=xf86confmalloc(sizeof(XF86ConfScreenRec));
+			memset(screen,0,sizeof(XF86ConfScreenRec));
+
+			/* calculate identifier from key basename */
+			dataSize=keyGetBaseNameSize(key);
+			screen->scrn_identifier=xf86confmalloc(dataSize);
+			keyGetBaseName(key,screen->scrn_identifier,dataSize);
+
+			/* Get Driver (obsolete) */
+			genericKey = keyNew(KEY_SWITCH_END);
+			ret=kdbGetKeyByParentKey(key,"Driver",genericKey);
+			if (ret == 0) {
+				dataSize=keyGetDataSize(genericKey);
+				screen->scrn_obso_driver=xf86confmalloc(dataSize);
+				keyGetString(genericKey,screen->scrn_obso_driver,dataSize);
+			}
+			keyClose(genericKey);
+
+
+			/* Get DefaultDepth */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(key,"DefaultDepth",genericKey);
+			if (ret == 0) {
+				keyGetString(genericKey,buffer,sizeof(buffer));
+				screen->scrn_defaultdepth=strtol(buffer, NULL, 10);
+			}
+			keyClose(genericKey);
+
+
+			/* Get DefaultBPP */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(key,"DefaultBPP",genericKey);
+			if (ret == 0) {
+				keyGetString(genericKey,buffer,sizeof(buffer));
+				screen->scrn_defaultbpp=strtol(buffer, NULL, 10);
+			}
+			keyClose(genericKey);
+
+
+			/* Get DefaultFbBPP */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(key,"DefaultFbBPP",genericKey);
+			if (ret == 0) {
+				keyGetString(genericKey,buffer,sizeof(buffer));
+				screen->scrn_defaultfbbpp=strtol(buffer, NULL, 10);
+			}
+			keyClose(genericKey);
+
+
+			/* Get Device */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(key,"Device",genericKey);
+			if (ret == 0) {
+				dataSize=keyGetDataSize(genericKey);
+				screen->scrn_device_str=xf86confmalloc(dataSize);
+				keyGetString(genericKey,screen->scrn_device_str,dataSize);
+			}
+			keyClose(genericKey);
+
+
+			/* Get Monitor */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(key,"Monitor",genericKey);
+			if (ret == 0) {
+				dataSize=keyGetDataSize(genericKey);
+				screen->scrn_monitor_str=xf86confmalloc(dataSize);
+				keyGetString(genericKey,screen->scrn_monitor_str,dataSize);
+			}
+			keyClose(genericKey);
+
+
+			/* Get VideoAdaptor  */
+			keyInit(genericKey);
+			ret=kdbGetKeyByParentKey(key,"VideoAdaptor",genericKey);
+			if (ret == 0) {
+				char buffer[300];
+				char *cursor,*cursorEnd;
+
+				keyGetString(genericKey,buffer,sizeof(buffer));
+
+				cursor=buffer;
+				do {
+					XF86ConfAdaptorLinkPtr aptr;
+
+					cursorEnd=index(cursor,',');
+					if (cursorEnd) {
+						*cursorEnd=0;
+						cursorEnd++;
+					}
+
+					/* Don't allow duplicates */
+					for (aptr = screen->scrn_adaptor_lst; aptr;
+						aptr = (XF86ConfAdaptorLinkPtr) aptr->list.next)
+						if (xf86nameCompare (cursor, aptr->al_adaptor_str)==0)
+							break;
+
+					if (aptr == NULL) {
+						aptr = xf86confmalloc (sizeof(XF86ConfAdaptorLinkRec));
+						memset(aptr,0,sizeof(XF86ConfAdaptorLinkRec));
+						aptr->al_adaptor_str=xf86confmalloc(strlen(cursor));
+						strcpy(aptr->al_adaptor_str,cursor);
+						screen->scrn_adaptor_lst = (XF86ConfAdaptorLinkPtr)
+							xf86addListItem ((glp) screen->scrn_adaptor_lst,
+							(glp) aptr);
+					}
+					cursor=cursorEnd;
+				} while (cursor);
+			}
+			keyDel(genericKey);
+
+
+			/* Get Display subsections */
+			dataSize=keyGetFullNameSize(key)+30;
+			options=xf86confmalloc(dataSize);
+			keyGetFullName(key,options,dataSize);
+			strcat(options,"/Displays");
+
+			optionKeys = ksNew();
+			kdbGetChildKeys(options,optionKeys,KDB_O_SORT | KDB_O_DIR);
+			if (ksGetSize(optionKeys))
+				screen->scrn_display_lst=ksToDisplays(optionKeys);
+			xf86conffree (options);
+			ksClose(optionKeys);
+
+
+
+			/* Now get this screen's options */
+			dataSize=keyGetFullNameSize(key)+30;
+			options=xf86confmalloc(dataSize);
+			keyGetFullName(key,options,dataSize);
+			strcat(options,"/Options");
+
+			ksInit(optionKeys);
+			kdbGetChildKeys(options,optionKeys,KDB_O_SORT);
+			if (ksGetSize(optionKeys))
+				screen->scrn_option_lst=ksToOptions(optionKeys);
+			xf86conffree (options);
+			ksDel(optionKeys);
+
+			/* Finished with this Screen. Now add to our screens list */
+			if (ptr) ptr=(XF86ConfScreenPtr)
+				xf86addListItem ((glp) ptr, (glp) screen);
+			else  ptr=screen;
+		}
+	}
+
+	ksDel(screens);
+
+#ifdef DEBUG
+	printf ("Screen keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+/*
+ * Elektra version of Screen.c::xf86printScreenSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfScreenPtr struct
+ * plus a root key name.
+ * 
+ */
+void
+xf86addScreens (KeySet *ks, const char *root, XF86ConfScreenPtr ptr)
+{
+	XF86ConfAdaptorLinkPtr aptr;
+	XF86ConfDisplayPtr dptr;
+	XF86ModePtr mptr;
+
+	Key *key;
+	char buffer[300];
+	char screenroot[300];
+	char *superbuffer=NULL;
+	unsigned dn=0;
+
+	while (ptr)
+	{
+		sprintf(screenroot,"%s/Screens/%s",root,ptr->scrn_identifier);
+
+		/* Elektrify . . .
+		if (ptr->scrn_comment)
+			fprintf (cf, "%s", ptr->scrn_comment);
+		*/
+
+		if (ptr->scrn_obso_driver) {
+			sprintf(buffer,"%s/%s",screenroot,"Driver");
+			key = keyNew(buffer,
+     					KEY_SWITCH_VALUE, ptr->scrn_obso_driver,					
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->scrn_device_str) {
+			sprintf(buffer,"%s/%s",screenroot,"Device");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->scrn_device_str,
+					KEY_SWITCH_END);			
+			ksAppend(ks,key);
+		}
+
+		if (ptr->scrn_monitor_str) {
+			sprintf(buffer,"%s/%s",screenroot,"Monitor");
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->scrn_monitor_str,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->scrn_defaultdepth) {
+			sprintf(buffer,"%s/%s",screenroot,"DefaultDepth");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"%d",ptr->scrn_defaultdepth);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->scrn_defaultbpp) {
+			sprintf(buffer,"%s/%s",screenroot,"DefaultBPP");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"%d",ptr->scrn_defaultbpp);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->scrn_defaultfbbpp) {
+			sprintf(buffer,"%s/%s",screenroot,"DefaultFbBPP");
+			key = keyNew(buffer, KEY_SWITCH_END);
+			sprintf(buffer,"%d",ptr->scrn_defaultfbbpp);
+			keySetString(key,buffer);
+			ksAppend(ks,key);
+		}
+
+		sprintf(buffer,"%s/Options",screenroot);
+		xf86addOptions(ks,buffer,ptr->scrn_option_lst);
+
+
+
+		for (aptr = ptr->scrn_adaptor_lst; aptr; aptr = aptr->list.next)
+		{
+			if (!superbuffer)
+				superbuffer=xf86confmalloc(strlen(aptr->al_adaptor_str)+1);
+			else {
+				char *tmp;
+
+				tmp=xf86confmalloc(strlen(aptr->al_adaptor_str) +
+					strlen(superbuffer) + 1);
+				strcpy(tmp,superbuffer);
+				xf86conffree(superbuffer);
+				superbuffer=tmp;
+				strcat(superbuffer,",");
+				strcat(superbuffer,aptr->al_adaptor_str);
+			}
+		}
+		if (superbuffer) {
+			sprintf(buffer,"%s/%s",screenroot,"VideoAdaptor");
+			key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, superbuffer,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+
+			xf86conffree(superbuffer);
+		}
+
+
+		for (dptr = ptr->scrn_display_lst; dptr; dptr = dptr->list.next)
+		{
+			char disproot[300];
+
+			sprintf(disproot,"%s/Displays/%02d",screenroot,dn);
+			++dn;
+
+			/* Figure out comments....
+			if (dptr->disp_comment)
+				fprintf (cf, "%s", dptr->disp_comment);
+			*/
+			if (dptr->disp_frameX0 >= 0 || dptr->disp_frameY0 >= 0)
+			{
+				sprintf(buffer,"%s/%s",disproot,"Viewport.x");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%d",dptr->disp_frameX0);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+
+				sprintf(buffer,"%s/%s",disproot,"Viewport.y");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%d",dptr->disp_frameY0);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_virtualX != 0 || dptr->disp_virtualY != 0)
+			{
+				sprintf(buffer,"%s/%s",disproot,"Virtual.x");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%d",dptr->disp_virtualX);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+
+				sprintf(buffer,"%s/%s",disproot,"Virtual.y");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%d",dptr->disp_virtualY);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_depth)
+			{
+				sprintf(buffer,"%s/%s",disproot,"Depth");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%d",dptr->disp_depth);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_bpp)
+			{
+				sprintf(buffer,"%s/%s",disproot,"FbBPP");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%d",dptr->disp_bpp);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_visual)
+			{
+				sprintf(buffer,"%s/%s",disproot,"Visual");
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, dptr->disp_visual,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_weight.red != 0)
+			{
+				sprintf(buffer,"%s/%s",disproot,"Weight.red");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%d",dptr->disp_weight.red);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+
+				sprintf(buffer,"%s/%s",disproot,"Weight.green");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%d",dptr->disp_weight.green);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+
+				sprintf(buffer,"%s/%s",disproot,"Weight.blue");
+				key = keyNew(buffer, KEY_SWITCH_END);						
+				sprintf(buffer,"%d",dptr->disp_weight.blue);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_black.red != -1)
+			{
+				sprintf(buffer,"%s/%s",disproot,"Black.red");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"0x%04x",dptr->disp_black.red);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+
+				sprintf(buffer,"%s/%s",disproot,"Black.green");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"0x%04x",dptr->disp_black.green);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+
+				sprintf(buffer,"%s/%s",disproot,"Black.blue");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"0x%04x",dptr->disp_black.blue);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_white.red != -1)
+			{
+				sprintf(buffer,"%s/%s",disproot,"White.red");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"0x%04x",dptr->disp_white.red);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+
+				sprintf(buffer,"%s/%s",disproot,"White.green");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"0x%04x",dptr->disp_white.green);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+
+				sprintf(buffer,"%s/%s",disproot,"White.blue");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"0x%04x",dptr->disp_white.blue);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_mode_lst)
+			{
+				sprintf(buffer,"%s/%s",disproot,"Modes");
+				key = keyNew(buffer, KEY_SWITCH_END);
+
+				buffer[0]=0;
+				for (mptr = dptr->disp_mode_lst; mptr; mptr = mptr->list.next)
+				{
+					if (buffer[0] != 0)
+						strcat(buffer,",");
+					strcat(buffer,mptr->mode_name);
+				}
+
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+			}
+
+			xf86addOptions(ks,disproot,dptr->disp_option_lst);
+		}
+		ptr = ptr->list.next;
+	}
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Module.c::xf86parseModuleSection() and
+ * xf86parseModuleSubSection() functions.
+ *
+ * Fetch keys under [rootKey]/Modules .
+ *
+ */
+XF86ConfModulePtr
+xf86getModules (const char *rootKey)
+{
+	KeySet *ksModules;
+	Key *key;
+	Key *loadDriver;
+	int ret;
+	char localRootKey[sizeof(rootKey)+100];
+
+	parsePrologue (XF86ConfModulePtr, XF86ConfModuleRec)
+
+	strcpy(localRootKey,rootKey);
+	strcat(localRootKey,"/Modules");
+
+
+	/* Look for the (undocumented) LoadDriver modules */
+	loadDriver = keyNew(KEY_SWITCH_END);
+	ret=kdbGetKeyByParent(localRootKey,"LoadDrivers",loadDriver);
+	if (ret == 0) {
+		char buffer[300];
+		char *cursor, *cursorEnd;
+
+		keyGetString(loadDriver,buffer,sizeof(buffer));
+		cursor=buffer;
+		do {
+			char *name=NULL;
+
+			cursorEnd=index(cursor,',');
+			if (cursorEnd) {
+				*cursorEnd=0;
+				cursorEnd++;
+			}
+
+			name=xf86confmalloc(strlen(cursor)+1);
+			strcpy(name,cursor);
+
+			ptr->mod_load_lst =
+			xf86addNewLoadDirective (ptr->mod_load_lst, name,
+				XF86_LOAD_DRIVER, NULL);
+
+			cursor=cursorEnd;
+		} while (cursor);
+	}
+	keyDel(loadDriver);
+
+
+	/* Look for the modules to be loaded and their options */
+	ksModules = ksNew();
+	kdbGetChildKeys(localRootKey,ksModules,KDB_O_NOVALUE | KDB_O_DIR);
+
+	if (ksGetSize(ksModules)) {
+		ksRewind(ksModules);
+		while ((key=ksNext(ksModules))) {
+			XF86LoadPtr lptr;
+			KeySet *optionKeys;
+			size_t size;
+
+			lptr=xf86confmalloc(sizeof(XF86LoadRec));
+			memset(lptr,0,sizeof(XF86LoadRec));
+			lptr->load_type=XF86_LOAD_MODULE;
+			size=keyGetBaseNameSize(key);
+			lptr->load_name=xf86confmalloc(size);
+			keyGetBaseName(key,lptr->load_name,size);
+
+			optionKeys = ksNew();
+			keyGetName(key,localRootKey,sizeof(localRootKey));
+			kdbGetChildKeys(localRootKey,optionKeys,KDB_O_SORT);
+			if (ksGetSize(optionKeys))
+				lptr->load_opt=ksToOptions(optionKeys);
+			ksDel(optionKeys);
+
+			ptr->mod_load_lst=(XF86LoadPtr)
+				xf86addListItem((glp)ptr->mod_load_lst,(glp)lptr);
+		}
+	}
+	ksDel(ksModules);
+
+#ifdef DEBUG
+	printf ("Module keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+/*
+ * Elektra version of Modules.c::xf86printModuleSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfModulePtr struct
+ * plus a root key name.
+ * 
+ */
+void
+xf86addModules (KeySet *ks, const char *root, XF86ConfModulePtr ptr) {
+	XF86LoadPtr lptr;
+	Key *key;
+	char buffer[300];
+	char modroot[300];
+	char *loaddrivers=NULL;
+
+	if (ptr == NULL)
+		return;
+
+	sprintf(modroot,"%s/%s",root,"Modules");
+
+	/* figure out how to Elektrify comments . . . .
+	if (ptr->mod_comment)
+		fprintf(cf, "%s", ptr->mod_comment);
+	*/
+
+	for (lptr = ptr->mod_load_lst; lptr; lptr = lptr->list.next)
+	{
+		switch (lptr->load_type)
+		{
+		case XF86_LOAD_MODULE:
+			sprintf(buffer,"%s/%s",modroot,lptr->load_name);
+			key = keyNew(buffer,
+					KEY_SWITCH_TYPE, KEY_TYPE_DIR,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+
+			if( lptr->load_opt) {
+				xf86addOptions(ks,buffer,lptr->load_opt);
+			}
+			break;
+		case XF86_LOAD_DRIVER:
+			if (loaddrivers==0)
+				loaddrivers=xf86confmalloc(strlen(lptr->load_name));
+			else {
+				char *tmp=xf86confmalloc(strlen(lptr->load_name) +
+					strlen(loaddrivers) + 1 /* for the coma */);
+
+				strcpy(tmp,loaddrivers);
+				strcat(tmp,",");
+				xf86conffree(loaddrivers);
+				loaddrivers=tmp;
+				strcat(loaddrivers,lptr->load_name);
+			}
+			break;
+#if 0
+		default:
+			fprintf (cf, "#\tUnknown type  \"%s\"\n", lptr->load_name);
+			break;
+#endif
+		}
+	}
+
+	if (loaddrivers) {
+		sprintf(buffer,"%s/%s",modroot,"LoadDrivers");
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, loaddrivers,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+	}
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Layout.c::xf86parseLayoutSection() function.
+ *
+ * Fetch keys under [rootKey]/Layouts .
+ *
+ */
+XF86ConfLayoutPtr
+xf86getLayout (const char *rootKey)
+{
+	XF86ConfLayoutPtr lay=NULL; /* we'll return this */
+	KeySet *layouts;
+	KeySet *screens;
+	KeySet *inputs;
+	KeySet *options;
+	Key *key,*layout;
+	char buffer[300];
+	size_t size;
+
+	strcpy(buffer,rootKey);
+	strcat(buffer,"/Layouts");
+
+	layouts = ksNew();
+	kdbGetChildKeys(buffer,layouts,KDB_O_SORT | KDB_O_DIR);
+	ksRewind(layouts);
+	while ((layout=ksNext(layouts))) {
+		parsePrologue (XF86ConfLayoutPtr, XF86ConfLayoutRec)
+
+		/* Calculate Identifier */
+		size=keyGetBaseNameSize(layout);
+		ptr->lay_identifier=xf86confmalloc(size);
+		keyGetBaseName(layout,ptr->lay_identifier,size);
+
+		/* Get screens layout */
+		keyGetName(layout,buffer,sizeof(buffer));
+		strcat(buffer,"/Screens");
+
+		screens = ksNew();
+		kdbGetChildKeys(buffer,screens,KDB_O_SORT | KDB_O_DIR);
+		ksRewind(screens);
+		while ((key=ksNext(screens))) {
+			XF86ConfAdjacencyPtr aptr;
+			KeySet *screenParameters;
+			Key *screenPar;
+
+			/* initialize object */
+			aptr=xf86confmalloc (sizeof (XF86ConfAdjacencyRec));
+			aptr->list.next = NULL;
+			aptr->adj_scrnum = -1;
+			aptr->adj_where = CONF_ADJ_OBSOLETE;
+			aptr->adj_x = 0;
+			aptr->adj_y = 0;
+			aptr->adj_refscreen = NULL;
+
+			/* Get screen name */
+			size=keyGetBaseNameSize(key);
+			aptr->adj_screen_str=xf86confmalloc(size);
+			keyGetBaseName(key,aptr->adj_screen_str,size);
+			keyGetName(key,buffer,sizeof(buffer));
+
+			screenParameters = ksNew();
+			kdbGetChildKeys(buffer,screenParameters,KDB_O_DIR | KDB_O_SORT);
+			ksRewind(screenParameters);
+			while ((screenPar=ksNext(screenParameters))) {
+				keyGetBaseName(screenPar,buffer,sizeof(buffer));
+				if (strcmp(buffer,"RightOf") == 0)
+					aptr->adj_where = CONF_ADJ_RIGHTOF;
+				else if (strcmp(buffer,"LeftOf") == 0)
+					aptr->adj_where = CONF_ADJ_LEFTOF;
+				else if (strcmp(buffer,"Above") == 0)
+					aptr->adj_where = CONF_ADJ_ABOVE;
+				else if (strcmp(buffer,"Below") == 0)
+					aptr->adj_where = CONF_ADJ_BELOW;
+				else if (strcmp(buffer,"Relative") == 0)
+					aptr->adj_where = CONF_ADJ_RELATIVE;
+				else if (strcmp(buffer,"Relative.x") == 0) {
+					aptr->adj_where = CONF_ADJ_RELATIVE;
+					keyGetString(screenPar,buffer,sizeof(buffer));
+					aptr->adj_x=strtol(buffer,NULL,10);
+				} else if (strcmp(buffer,"Relative.y") == 0) {
+					aptr->adj_where = CONF_ADJ_RELATIVE;
+					keyGetString(screenPar,buffer,sizeof(buffer));
+					aptr->adj_y=strtol(buffer,NULL,10);
+				} else if (strcmp(buffer,"Absolute.x") == 0) {
+					aptr->adj_where = CONF_ADJ_ABSOLUTE;
+					keyGetString(screenPar,buffer,sizeof(buffer));
+					aptr->adj_x=strtol(buffer,NULL,10);
+				} else if (strcmp(buffer,"Absolute.y") == 0) {
+					aptr->adj_where = CONF_ADJ_ABSOLUTE;
+					keyGetString(screenPar,buffer,sizeof(buffer));
+					aptr->adj_y=strtol(buffer,NULL,10);
+				} else if (strcmp(buffer,"ScreenNumber") == 0) {
+					keyGetString(screenPar,buffer,sizeof(buffer));
+					aptr->adj_scrnum=strtol(buffer,NULL,10);
+				}
+
+				switch (aptr->adj_where) {
+					case CONF_ADJ_RIGHTOF:
+					case CONF_ADJ_LEFTOF:
+					case CONF_ADJ_ABOVE:
+					case CONF_ADJ_BELOW:
+					case CONF_ADJ_RELATIVE:
+						size=keyGetDataSize(screenPar);
+						aptr->adj_refscreen=xf86confmalloc(size);
+						keyGetString(screenPar,aptr->adj_refscreen,size);
+				}
+
+			}
+			
+			ptr->lay_adjacency_lst = (XF86ConfAdjacencyPtr)
+				xf86addListItem ((glp) ptr->lay_adjacency_lst, (glp) aptr);
+			
+			ksDel(screenParameters);
+		}
+		ksDel(screens);
+
+
+		/* Get used input devices */
+		keyGetName(layout,buffer,sizeof(buffer));
+		strcat(buffer,"/Inputs/"); /* we need the leading '/' */
+
+		inputs = ksNew();
+		kdbGetChildKeys(buffer,inputs,KDB_O_SORT | KDB_O_DIR);
+		ksRewind(inputs);
+		while ((key=ksNext(inputs))) {
+			XF86ConfInputrefPtr iptr;
+			KeySet *iopts;
+			char dev[300];
+			size_t size;
+
+			iptr = xf86confmalloc (sizeof (XF86ConfInputrefRec));
+			iptr->list.next = NULL;
+			iptr->iref_option_lst = NULL;
+
+			size=keyGetBaseNameSize(key);
+			iptr->iref_inputdev_str = xf86confmalloc(size);
+			keyGetBaseName(key,iptr->iref_inputdev_str,size);
+
+			/* Get options for current input device */
+			strcpy(dev,buffer);
+			strcat(dev,iptr->iref_inputdev_str);
+
+			iopts = ksNew();
+			kdbGetChildKeys(dev,iopts,KDB_O_SORT);
+			if (ksGetSize(iopts))
+				iptr->iref_option_lst=ksToOptions(iopts);
+			ksDel(iopts);
+			
+			ptr->lay_input_lst = (XF86ConfInputrefPtr)
+				xf86addListItem ((glp) ptr->lay_input_lst, (glp) iptr);
+		}
+		ksDel(inputs);
+
+		/* Get general Layout Options */
+		keyGetName(layout,buffer,sizeof(buffer));
+		strcat(buffer,"/Options");
+
+		options = ksNew();
+		kdbGetChildKeys(buffer,options,KDB_O_SORT);
+		if (ksGetSize(options))
+			ptr->lay_option_lst=ksToOptions(options);
+		ksDel(options);
+
+		/* Finalize adding to the list */
+		lay=(XF86ConfLayoutPtr)xf86addListItem ((glp) lay, (glp) ptr);
+	}
+	ksDel(layouts);
+
+#ifdef DEBUG
+	printf ("Server Layouts grabed\n");
+#endif
+
+	return lay;
+}
+
+
+
+/*
+ * Elektra version of Layout.c::xf86printLayoutSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfLayoutPtr struct
+ * plus a root key name.
+ * 
+ */
+void
+xf86addLayout(KeySet *ks, const char *root, XF86ConfLayoutPtr ptr) {
+	XF86ConfAdjacencyPtr aptr;
+	XF86ConfInputrefPtr inptr;
+
+	char buffer[300];
+	char layroot[300];
+	Key *key;
+
+	while (ptr) {
+		sprintf(layroot,"%s/Layouts/%s",root,ptr->lay_identifier);
+
+		/* Figure out where to put this....
+		if (ptr->lay_comment)
+			fprintf (cf, "%s", ptr->lay_comment);
+		*/
+
+		for (aptr = ptr->lay_adjacency_lst; aptr; aptr = aptr->list.next)
+		{
+			char screenroot[300];
+
+			sprintf(screenroot,"%s/Screens/%s",layroot,aptr->adj_screen_str);
+
+			if (aptr->adj_scrnum >= 0) {
+				sprintf(buffer,"%s/%s",screenroot,"ScreenNumber");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%d",aptr->adj_scrnum);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+			}
+
+			switch(aptr->adj_where)
+			{
+/*			case CONF_ADJ_OBSOLETE:
+				fprintf (cf, " \"%s\"", aptr->adj_top_str);
+				fprintf (cf, " \"%s\"", aptr->adj_bottom_str);
+				fprintf (cf, " \"%s\"", aptr->adj_right_str);
+				fprintf (cf, " \"%s\"\n", aptr->adj_left_str);
+				break;*/
+			case CONF_ADJ_ABSOLUTE:
+				if (aptr->adj_x != -1) {
+					sprintf(buffer,"%s/%s",screenroot,"Absolute.x");
+					key = keyNew(buffer, KEY_SWITCH_END);
+					sprintf(buffer,"%d",aptr->adj_x);
+					keySetString(key,buffer);
+					ksAppend(ks,key);
+
+					sprintf(buffer,"%s/%s",screenroot,"Absolute.y");
+					key = keyNew(buffer, KEY_SWITCH_END);
+					sprintf(buffer,"%d",aptr->adj_y);
+					keySetString(key,buffer);
+					ksAppend(ks,key);
+				}
+				break;
+			case CONF_ADJ_RIGHTOF:
+				sprintf(buffer,"%s/%s",screenroot,"RightOf");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%s",aptr->adj_refscreen);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+				break;
+			case CONF_ADJ_LEFTOF:
+				sprintf(buffer,"%s/%s",screenroot,"LeftOf");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%s",aptr->adj_refscreen);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+				break;
+			case CONF_ADJ_ABOVE:
+				sprintf(buffer,"%s/%s",screenroot,"Above");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%s",aptr->adj_refscreen);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+				break;
+			case CONF_ADJ_BELOW:
+				sprintf(buffer,"%s/%s",screenroot,"Below");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%s",aptr->adj_refscreen);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+				break;
+			case CONF_ADJ_RELATIVE:
+				sprintf(buffer,"%s/%s",screenroot,"Relative");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%s",aptr->adj_refscreen);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+
+				sprintf(buffer,"%s/%s",screenroot,"Relative.x");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%d",aptr->adj_x);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+
+				sprintf(buffer,"%s/%s",screenroot,"Relative.y");
+				key = keyNew(buffer, KEY_SWITCH_END);
+				sprintf(buffer,"%d",aptr->adj_y);
+				keySetString(key,buffer);
+				ksAppend(ks,key);
+
+				break;
+			}
+		}
+
+		/* Convert to Elektra....
+		for (iptr = ptr->lay_inactive_lst; iptr; iptr = iptr->list.next)
+			fprintf (cf, "\tInactive       \"%s\"\n", iptr->inactive_device_str);
+		*/
+
+		for (inptr = ptr->lay_input_lst; inptr; inptr = inptr->list.next)
+		{
+			char inputroot[300];
+
+			sprintf(inputroot,"%s/Inputs/%s",layroot,inptr->iref_inputdev_str);
+
+			xf86addOptions(ks,inputroot,inptr->iref_option_lst);
+		}
+
+		/* The generic Layout options */
+		xf86addOptions(ks, layroot ,ptr->lay_option_lst);
+
+		ptr = ptr->list.next;
+	}
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#undef CLEANUP
+#define CLEANUP xf86freeConfig
+
+
+/*
+ * Triggers all xf86get*() to fetch X.org configuration keys, and assemble a
+ * XF86ConfigPtr structure to be returned.
+ *
+ * This function is exported in elektra.h and will be called by
+ * xc/programs/Xserver/hw/xfree86/common/xf86Config.c::xf86HandleConfigFile()
+ *
+ * Elektra version for read.c::xf86readConfigFile() that triggers the read of
+ * plain-text human-readable xorg.conf file.
+ *
+ */
+XF86ConfigPtr
+xf86getConfigKeys (const char *rootKey)
+{
+	XF86ConfigPtr ptr = NULL;
+	Key *kroot;
+	
+	kdbOpen();
+
+	if ((ptr = xf86confcalloc(1, sizeof(XF86ConfigRec))) == NULL)	
+	{
+		return NULL;
+	}
+	memset (ptr, 0, sizeof (XF86ConfigRec));
+
+	/* First check if root key is there to avoid tons of key fetching */
+	kroot = keyNew(rootKey, KEY_SWITCH_END);
+	if (kdbStatKey(kroot) == 0) {
+
+		/* assemble sub-structures */
+		ptr->conf_files = xf86getFiles (rootKey);
+	
+		ptr->conf_flags = xf86getFlags (rootKey);
+	
+		/* keyboard, mouse and generic input */
+		ptr->conf_input_lst = xf86getInput (rootKey);
+	
+		ptr->conf_device_lst = xf86getDevice (rootKey);
+	
+		ptr->conf_monitor_lst = xf86getMonitor (rootKey);
+	
+		ptr->conf_modes_lst = xf86getModes (rootKey);
+	
+		ptr->conf_screen_lst = xf86getScreen (rootKey);
+	
+		ptr->conf_modules = xf86getModules (rootKey);
+	
+		ptr->conf_layout_lst = xf86getLayout (rootKey);
+		/*ptr->conf_vendor_lst = xf86getVendor (rootKey);*/
+	
+		ptr->conf_dri = xf86getDRI (rootKey);
+		/*ptr->conf_videoadaptor_lst = xf86getVideo (rootKey);*/
+	}
+	
+	keyDel(kroot);
+	kdbClose();
+
+	/* validate and return */
+	if (xf86validateConfig (ptr))
+		return (ptr);
+	else
+	{
+		CLEANUP (ptr);
+		return (NULL);
+	}
+}
+
+
+
+/*
+ * Converts X internal structs into Elektra Keys.
+ * It does that triggering all xf86add*() functions.
+ *
+ * This function is exported in elektra.h and will be called by
+ * xc/programs/Xserver/hw/xfree86/common/xf86Config.c::xf86HandleConfigFile()
+ *
+ * Elektra version to write.c::xf86writeConfigFile() function.
+ *
+ */
+KeySet *xf86collectConfigKeys (const char *root, XF86ConfigPtr cptr) {
+	KeySet *ks=0;
+
+	ks = ksNew();
+
+	xf86addFiles(   ks, root, cptr->conf_files);
+
+	xf86addFlags(   ks, root, cptr->conf_flags);
+
+	xf86addInput(   ks, root, cptr->conf_input_lst);
+
+	xf86addDevice(  ks, root, cptr->conf_device_lst);
+
+	xf86addMonitor( ks, root, cptr->conf_monitor_lst);
+
+	xf86addModes(   ks, root, cptr->conf_modes_lst);
+
+	xf86addLayout(  ks, root, cptr->conf_layout_lst);
+
+	xf86addModules( ks, root, cptr->conf_modules);
+
+	xf86addScreens( ks, root, cptr->conf_screen_lst);
+
+	xf86addDRI(     ks, root, cptr->conf_dri);
+
+
+	if (ksGetSize(ks) == 0) {
+		xf86conffree(ks);
+		ks=0;
+	}
+
+	return ks;
+}
diff -Naur xc.orig/programs/Xserver/hw/xfree86/parser/elektra.h xc/programs/Xserver/hw/xfree86/parser/elektra.h
--- xc.orig/programs/Xserver/hw/xfree86/parser/elektra.h	1970-01-01 01:00:00.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/parser/elektra.h	2006-02-07 16:21:06.000000000 +0100
@@ -0,0 +1,61 @@
+/* $Id$ */
+
+
+/*
+ * Copyright (c) 2004 by Avi Alkalay <avi at unix.sh>
+ *
+ * The Elektra Project :: http://elektra.sourceforge.net
+ *
+ */
+
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+
+/* 
+ * This file contains the external interfaces for the X.org configuration
+ * based on a Key Database (Elektra).
+ */
+ 
+#ifndef _elektra_h_
+#define _elektra_h_
+
+
+
+#include "xf86Parser.h"
+#include <kdb.h> /* Elektra */
+
+/* Grab the configuration and put in X internal structs */
+extern XF86ConfigPtr xf86getConfigKeys (const char *rootKey);
+
+
+/* Convert X internal structs to Elektra Keys */
+extern KeySet *xf86collectConfigKeys (const char *root, XF86ConfigPtr);
+
+
+#endif /* _elektra_h_ */
+
diff -Naur xc.orig/programs/Xserver/hw/xfree86/parser/Imakefile xc/programs/Xserver/hw/xfree86/parser/Imakefile
--- xc.orig/programs/Xserver/hw/xfree86/parser/Imakefile	2006-02-07 16:18:21.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/parser/Imakefile	2006-02-07 16:40:26.000000000 +0100
@@ -16,7 +16,12 @@
 DBMALLOCDEFINE=-DDBMALLOC
 #endif
 
-SYS_LIBRARIES = MathLibrary
+#if defined(UseElektra)
+ELEKTRA_LIBRARIES=-L/lib -lelektra
+#endif
+
+SYS_LIBRARIES = MathLibrary  $(ELEKTRA_LIBRARIES)
+
 
 XCONFIGFILE = XConfigFile
 XCONFIGDIR = XConfigDir
@@ -37,6 +42,11 @@
 	Video.o Monitor.o Pointer.o Screen.o Vendor.o read.o scan.o write.o \
 	DRI.o Extensions.o
 
+#if defined(UseElektra)
+SRCS += elektra.c
+OBJS += elektra.o
+#endif
+
 CONFIG_DEFINES = -DXCONFIGDIR=\"$(XCONFIGDIR)\" \
 		 -DXCONFIGFILE=\"$(XCONFIGFILE)\" \
 		 -DXVERSION="$(XVERS)"
@@ -48,6 +58,10 @@
 SpecialCObjectRule(scan,NullParameter,$(CONFIG_DEFINES) $(MODULEDEFINES) $(EXT_DEFINES) $(PICFLAGS))
 
 NormalProgramTarget(cpconfig,cpconfig.o $(OBJS),NullParameter,$(LOCAL_LIBRARIES),NullParameter)
-
+NormalProgramTarget(xelektrify,xelektrify.o $(OBJS),NullParameter,$(LOCAL_LIBRARIES),NullParameter)
+																															    
 AllTarget(ProgramTargetName(cpconfig))
+#if defined(UseElektra)
+AllTarget(ProgramTargetName(xelektrify))
+#endif
 DependTarget()
diff -Naur xc.orig/programs/Xserver/hw/xfree86/parser/README.Elektra xc/programs/Xserver/hw/xfree86/parser/README.Elektra
--- xc.orig/programs/Xserver/hw/xfree86/parser/README.Elektra	1970-01-01 01:00:00.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/parser/README.Elektra	2006-02-07 16:21:06.000000000 +0100
@@ -0,0 +1,206 @@
+ELEKTRIFYIED X.ORG: PRECISE AND PROGRAMATICALLY EASY X CONFIGURATION       |
+
+   Your X server has to work with your installed video card, monitor, find
+   your font server and dirs, modules, extensions, drivers, plugins.
+   You have to tell him how to integrate it all through its xorg.conf file.
+   If you need to change something, you start a text editor and use your
+   human brain and eyes to find the correct line, understand it, have the
+   skills to change it, and change it in order to work.
+   
+   This is good for advanced technical guys, but very bad for people that
+   don't have this skills, and in fact, don't really want to. He just
+   wants to change the screen resolution to make that projector work with his
+   laptop, and go ahead with his sales presentation. This is just an example.
+   
+   The point is: it is very difficult to make simple programs or scripts
+   that make simple changes to X configuration. Another example is a monitor
+   vendor that wants to support X, and for this he'd like to provide easy
+   installation of his product, without having to ask his user to read
+   documentation about horizontal Sync, and vertical refresh rates. For him
+   again is difficult to write some simple software that preciselly changes X
+   configuration to work correctly with his product.
+   
+   The xorg.conf file (as most Unix configuration files) was designed for
+   human beings.
+   
+   The Elektra Project (http://elektra.sourceforge.net) introduces a new way
+   to handle configurations through a clean API (or command line
+   tool) that accesses atomic configuration data, into a standarized
+   hierarchycal tree of key-value pairs. It is similar to GConf, but
+   designed for system-wide use, which also implies it does not have
+   dependencies.
+   
+   And this is what this patch is about: to make the X server look for its
+   configurations into a machine-ready tree of key-value pairs, instead of
+   the human-ready xorg.conf.
+  
+   So where you had to look for "Device radeon" into a "Section Device",
+   with the key/value tree, X and other programs can look for it
+   preciselly at
+   
+      system/sw/xorg/current/Devices/Videocard0/Driver = radeon
+
+   
+   Where you once had to "vi" your "Section Monitor", now X and other
+   programs can do it accessing the keys:
+   
+      system/sw/xorg/current/Monitors/Monitor0/HorizSync = 31.5 - 48.5
+      system/sw/xorg/current/Monitors/Monitor0/VertRefresh = 40.0 - 70.0
+      system/sw/xorg/current/Monitors/Monitor0/ModelName = IBM T40 LCD Panel
+      system/sw/xorg/current/Monitors/Monitor0/VendorName = IBM
+      system/sw/xorg/current/Monitors/Monitor0/Options/dpms
+  
+   
+   Where once the salesman above had to "vi" the Screen Section to change
+   the resolution, color depth, etc, a program can help him accessing:
+   
+      system/sw/xorg/current/Screens/Screen0/Displays/00/Depth=24
+      system/sw/xorg/current/Screens/Screen0/Displays/00/Modes=1024x768
+
+   
+   And so on....
+   
+   We believe an elektrified X server can leverage more plug-and-play
+   configurations, providing configuration power to HW vendors in a
+   very simple way, and making users experience less painfull.
+   
+   
+
+   
+      
+
+BEHAVIOR OF AN ELEKTRIFIED X SERVER
+
+   A patched X server will look for its configuration keys under the
+   namespace:
+   
+      system/sw/xorg/current   first, then if not found it tries
+      system/sw/xorg
+      
+   If not found, it will default to some xorg.conf file, parse it, and store
+   in its internal structures, then convert and commit it to a set of
+   keys under system/sw/xorg/current, and reload these keys.
+   
+   So you get automatic one-time conversion from xorg.conf to the
+   hierarchycal configuration key/value pairs 
+   
+   Very complex examples of xorg.conf files were tested for conversion. Even
+   undocumented configuration parameters (because the original source was
+   used as the reference).
+   
+   The Elektrifyied X server also works for the Red Hat Graphical Boot,
+   where you still don't have mounted partitions, network, etc.
+
+   
+      
+
+
+ELEKTRIFING X.ORG
+
+   You'll need the elektra-devel package installed in order to build X with
+   Elektra support.
+
+     1. Download and unpack X.org source code from
+     2. Download the xorg-x11-6.8.1-elektra.patch file from 
+     3. Apply it:
+         ~/src/xc$ cd ..
+         ~/src$ patch -p0 < xorg-x11-6.8.1-elektra.patch
+         ~/src$ cd xc
+         ~/src/xc$ # ...configure your build in host.def
+     4. Enable the patch:
+         ~/src/xc$ echo #define UseElektra >> config/cf/host.def
+     5. Build X.Org
+
+   You'll find the new X server as file xc/programs/Xserver/Xorg .
+   
+   The patch will add the following files:
+
+      xc/programs/Xserver/hw/xfree86/parser/
+        elektra.h (exported methods)
+        elektra.c (key fetching and X structs integration business logic)
+        xorg-example.conf (a very complex conf file to test conversion)
+        xelektrify.c (cmd to convert xorg.conf->keys and vice-versa)
+        README.Elektra (this file)
+   
+   And it will instrument 
+   xc/programs/Xserver/hw/xfree86/common/xf86Config.c::xf86HandleConfigFile()
+   to trigger the one-time conversion, and key fetching logic.
+   
+   And instrument the Imakefiles for correct builds:
+   
+      xc/programs/Xserver/hw/xfree86/parser/Imakefile
+      xc/programs/Xserver/hw/xfree86/common/Imakefile
+      xc/programs/Xserver/Imakefile
+      
+   If "#define UseElektra" is not present in host.def, the patch is
+   completelly disabled, and you'll get a binary-identicall built as before
+   applying the patch. All patched code are surrounded by #ifdefs.
+
+   
+   
+      
+
+ELEKTRA MEETS X.ORG SOURCE CODE
+or how we wrote the patch....
+
+   X.org has an xorg.conf parser that takes this steps to handle
+   configuration:
+   
+      1. Lexically parse the xorg.conf file
+      2. Put each Section info in an equivalent struct
+      3. Encapsulate all structs together and pass them to a validator
+      4. Use structs to define X behavior
+
+   This process is triggered by the xf86HandleConfigFile() method from
+   
+      xc/programs/Xserver/hw/xfree86/common/xf86Config.c
+   
+   Each xorg.conf Section has an equivalent structure defined in
+
+      xc/programs/Xserver/hw/xfree86/parser/xf86Parser.h
+      
+   and the lexycall analyzer code to parse each Section is under
+   
+      xc/programs/Xserver/hw/xfree86/parser/
+   
+   A fully parsed file has its equivalent structures encapsulated in a
+   parent XF86Config struct. We have:
+   
+      struct XF86ConfModuleRec for the "Section Modules"
+      struct XF86ConfMonitorRec for the "Section Monitor"
+      struct XF86ConfDeviceRec for the "Section Device"
+      etc...
+      
+   These structs are a pure computer representation of the text in each
+   Section, so the methods under "parser/" convert text to structs, and
+   the structs to text. This is how original X.org source handles xorg.conf.
+   
+   The Elektrification add methods that act in steps 1 and 2 above. And also
+   include methods to convert each struct to a KeySet. Both old (xorg.conf)
+   and new (Elektra) ways to get configuration information can live together
+   and they are actually used to automatically convert xorg.conf to keys. So
+   at the first time you'll run your elektrified X server, it will:
+
+      1. Not find configuration keys (because it is the first time)
+      2. Parse xorg.conf into structs
+      3. Convert structs to Keys
+      4. Commit the keys to key database
+      5. Reload configurations from the key database
+
+   See the behavior in the previous section.
+      
+   After assembling the XF86Config C structure, X will decode all its info
+   into more practicall parameters for its further operation.
+   
+   As a side note, with a key/value pair configuration hierarchy paradigm,
+   the XF86Config assembling code (the parser) could be avoided, making X
+   look for its configurations in a programatically easier, yet
+   human-readable, configuration organization.
+   We worked at the parser level to keep compatibility and to not go too
+   deep in X.org source code.
+
+   
+http://elektra.sourceforge.net
+The Elektra Project
+Avi Alkalay
+November 2004
\ Pas de fin de ligne  la fin du fichier.
diff -Naur xc.orig/programs/Xserver/hw/xfree86/parser/xelektrify.c xc/programs/Xserver/hw/xfree86/parser/xelektrify.c
--- xc.orig/programs/Xserver/hw/xfree86/parser/xelektrify.c	1970-01-01 01:00:00.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/parser/xelektrify.c	2006-02-07 16:21:06.000000000 +0100
@@ -0,0 +1,307 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/parser/cpconfig.c,v 1.6 2000/10/20 14:59:03 alanh Exp $ */
+/* 
+ * 
+ * Copyright (c) 1997  Metro Link Incorporated
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Metro Link shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Metro Link.
+ * 
+ */
+
+/* View/edit this file with tab stops set to 4 */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include "xf86Parser.h"
+#include "configProcs.h"
+#include "elektra.h"
+
+#ifdef MALLOC_FUNCTIONS
+void
+xfree (void *p)
+{
+	free (p);
+	return;
+}
+
+void *
+xalloc (int size)
+{
+	return malloc (size);
+}
+
+void *
+xrealloc (void *p, int size)
+{
+	return realloc (p, size);
+}
+
+#endif
+
+#define CONFPATH "%A,%R,/etc/X11/%R,%P/etc/X11/%R,%E,%F,/etc/X11/%F," \
+		 "%P/etc/X11/%F,%D/%X,/etc/X11/%X,/etc/%X,%P/etc/X11/%X.%H," \
+		 "%P/etc/X11/%X,%P/lib/X11/%X.%H,%P/lib/X11/%X"
+
+
+/**Some systems have even longer pathnames*/
+#ifdef PATH_MAX
+#define MAX_PATH_LENGTH PATH_MAX
+/**This value is garanteed on any Posixsystem*/
+#elif __USE_POSIX
+#define MAX_PATH_LENGTH _POSIX_PATH_MAX
+#else 
+#define MAX_PATH_LENGTH 4096
+#endif
+                          
+
+int conf2kdb;
+int xml;
+char gxorgconf[500]="";
+char grootkey[500]="";
+
+
+int
+parseCommandLine(int argc, char *argv[]) {
+	int fromApeared=0;
+	int opt;
+
+	while ((opt=getopt(argc,argv,"c:k:fx"))!=-1) {
+		switch (opt) {
+			case 'x':
+				xml=1;
+				break;
+			case 'c':
+				if (fromApeared) {
+					conf2kdb=1;
+					fromApeared=0;
+				}
+				strncpy(gxorgconf,optarg,sizeof(gxorgconf));
+				break;
+			case 'k':
+				if (fromApeared) {
+					conf2kdb=-1;
+					fromApeared=0;
+				}
+				strncpy(grootkey,optarg,sizeof(grootkey));
+				break;
+			case 'f':
+				fromApeared=1;
+				break;
+		}
+	}
+	
+	/* Verify and set some defaults */
+	if (conf2kdb == 0) conf2kdb=1;
+	
+	return 0;
+}
+
+
+int
+convert(int direction,char *xc,char *rk) {
+	const char *filename;
+	XF86ConfigPtr conf;
+	KeySet *ks=0;
+	char xorgconf[500]="";
+	char rootkey[500]="";
+	
+	if (direction == 1) {
+		
+		fprintf(stderr,"Converting a configuration file to a key database...\n");
+		if ((filename = xf86openConfigFile (CONFPATH, xc, NULL))) {
+			fprintf (stderr, "Opened %s for the config file\n", filename);
+		} else {
+			fprintf (stderr, "Unable to open config file\n");
+			return 1;
+		}
+
+		if ((conf = xf86readConfigFile ()) == NULL)
+			fprintf (stderr, "Problem when parsing config file\n");
+		xf86closeConfigFile ();
+		
+		/* Check if we have a good rootkey */
+		if (rk) strcpy(rootkey,rk);
+		else {
+			/* Defaults to our standard */
+			strcpy(rootkey,"system/sw/xorg/current");
+		}
+		
+		/* Put the in-memory X configurations in a KeySet, also in memory */
+		ks=xf86collectConfigKeys(rootkey,conf);
+		
+		if (xml) {
+			/* We only want an XML output */
+			ksToStream(ks,stdout,KDB_O_XMLHEADERS);
+		} else {
+			int ret; 
+			
+			/* Really commit to the Key database */
+			kdbOpen();
+			fprintf(stderr,"Writing X.org configuration keys to %s\n",rootkey);
+			ksRewind(ks);
+			ret=kdbSetKeys(ks);
+			if (ret != 0) {
+				Key *problem;
+				char error[500];
+				char keyname[300]="";
+		
+				problem=ksCurrent(ks);
+				if (problem) keyGetFullName(problem,keyname,sizeof(keyname));
+				sprintf(error,"Error when commiting %s",keyname);
+				perror(error);
+			}
+			kdbClose();
+			ksClose(ks);
+		}
+		
+	} else if (direction == -1) {
+		fprintf(stderr,"Converting a key database to a configuration file...\n");
+		
+		/* Check if we have a good rootkey */
+		if (rk) strcpy(rootkey,rk);
+		else {
+			/* Defaults to our standard */
+			strcpy(rootkey,"system/sw/xorg/current");
+		}
+		
+		conf=xf86getConfigKeys(rootkey);
+		
+		if (xc) {
+			fprintf(stderr, "Writing config file to `%s'\n", xc);
+			xf86writeConfigFile (xc, conf);
+		} else {
+			/* use stdout */
+			int fd;
+			ssize_t bytes;
+			char buffer[500];
+
+			strcpy(xorgconf,"/var/tmp/xorgconfXXXXXX");
+			
+			fd=mkstemp(xorgconf);
+			close(fd);
+			
+			xf86writeConfigFile (xorgconf, conf);
+			
+			fd=open(xorgconf,O_RDONLY);
+			if (fd) {
+				bytes=1;
+				while (bytes>0) {
+					bytes=read(fd,buffer,sizeof(buffer));
+					write(fileno(stdout),buffer,bytes);
+				}
+			}
+			
+			close(fd);
+			remove(xorgconf);
+		}
+	}
+}
+
+
+int
+main (int argc, char *argv[])
+{
+	char *xorgconf=0,*rootkey=0;
+
+	parseCommandLine(argc,argv);
+	
+	if (*gxorgconf) xorgconf=gxorgconf;
+	if (*grootkey) rootkey=grootkey;
+	
+	convert(conf2kdb,xorgconf,rootkey);
+
+/*	
+	const char *filename;
+	char *cmdline = NULL;
+	XF86ConfigPtr conf;
+	KeySet *ks;
+
+	fprintf(stderr,"Reading Xorg config keys\n");
+	conf=xf86getConfigKeys(argv[1]);
+	fprintf(stderr,"Xorg config keys read\n");
+*/
+/*	
+	if (argc > 1)
+	{
+		cmdline = argv[1];
+	}
+	if ((filename = xf86openConfigFile (CONFPATH, cmdline, NULL)))
+	{
+		fprintf (stderr, "Opened %s for the config file\n", filename);
+	}
+	else
+	{
+		fprintf (stderr, "Unable to open config file\n");
+		exit (1);
+	}
+
+	if ((conf = xf86readConfigFile ()) == NULL)
+	{
+		fprintf (stderr, "Problem when parsing config file\n");
+	}
+	else
+	{
+		fprintf (stderr, "Config file parsed OK\n");
+	}
+	xf86closeConfigFile ();
+*/                      
+/*
+	if (argc > 2) {
+		fprintf(stderr, "Writing config file to `%s'\n", argv[2]);
+		xf86writeConfigFile (argv[2], conf);
+	}
+*/
+/*
+	fprintf(stderr,"Writing config in old Xorg.conf format\n");
+	xf86writeConfigFile ("xis", conf);
+*/
+/*
+	ks=xf86collectConfigKeys("user/tmp/xorg",conf);
+
+	ksToStream(ks,stdout,KDB_O_XMLHEADERS);
+*/
+	exit(0);
+}
+
+/* Functions that the parser requires */
+
+void
+VErrorF(const char *f, va_list args)
+{
+	vfprintf(stderr, f, args);
+}
+
+void
+ErrorF(const char *f, ...)
+{
+	va_list args;
+
+	va_start(args, f);
+	vfprintf(stderr, f, args);
+	va_end(args);
+}
diff -Naur xc.orig/programs/Xserver/hw/xfree86/parser/xorg-example.conf xc/programs/Xserver/hw/xfree86/parser/xorg-example.conf
--- xc.orig/programs/Xserver/hw/xfree86/parser/xorg-example.conf	1970-01-01 01:00:00.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/parser/xorg-example.conf	2006-02-07 16:21:06.000000000 +0100
@@ -0,0 +1,275 @@
+Section "ServerLayout"
+    Identifier  "Simple Layout"
+    Screen "Screen 2"
+    Screen "Screen 1" Rightof "Screen 2"
+    InputDevice "Mouse1" "CorePointer"
+    InputDevice "Keyboard1" "CoreKeyboard"
+EndSection
+
+
+
+
+
+Section "ServerLayout"
+    Identifier  "Other Layout"
+    Screen "Screen 2"
+    Screen "Screen 1" Relative "Screen 2" 1200 0
+    InputDevice "Mouse1" "CorePointer"
+    InputDevice "Keyboard1" "CoreKeyboard"
+EndSection
+
+
+
+
+
+
+Section "Module"
+    Load        "dbe"   # Double buffer extension
+    SubSection  "extmod"
+      Option    "omit xfree86-dga"   # don't initialise the DGA extension
+    EndSubSection
+    Load        "type1"
+    Load        "freetype"
+# This loads the GLX module
+#    Load       "glx"
+EndSection
+
+
+
+
+
+Section "Files"
+    RgbPath     "/usr/X11R6/lib/X11/rgb"
+    FontPath   "/usr/X11R6/lib/X11/fonts/local/"
+    FontPath   "/usr/X11R6/lib/X11/fonts/misc/"
+    FontPath   "/usr/X11R6/lib/X11/fonts/75dpi/:unscaled"
+    FontPath   "/usr/X11R6/lib/X11/fonts/100dpi/:unscaled"
+    FontPath   "/usr/X11R6/lib/X11/fonts/Type1/"
+    FontPath   "/usr/X11R6/lib/X11/fonts/Speedo/"
+    FontPath   "/usr/X11R6/lib/X11/fonts/75dpi/"
+    FontPath   "/usr/X11R6/lib/X11/fonts/100dpi/"
+# The module search path.  The default path is shown here.
+#   ModulePath "/usr/X11R6/lib/modules"
+EndSection
+
+
+
+
+
+Section "ServerFlags"
+       Option "BlankTime" "10"
+       Option "HandleSpecialKeys" "WhenNeeded"
+EndSection
+
+
+
+
+
+
+Section "InputDevice"
+    Identifier  "Keyboard1"
+    Driver      "Keyboard"
+    Option "AutoRepeat" "500 30"
+    Option "XkbRules"   "xfree86"
+    Option "XkbModel"   "pc101"
+    Option "XkbLayout"  "us"
+EndSection
+
+
+
+
+
+Section "InputDevice"
+    Identifier  "Mouse1"
+    Driver      "mouse"
+    Option "Protocol"    "PS/2"
+    Option "Device"      "/dev/psaux"
+EndSection
+
+
+
+
+
+
+
+Section "Monitor"
+    Identifier  "Mini"
+    HorizSync   31.5
+    VertRefresh 50-90
+    Modeline "1280x1024@100" 190.960 1280 1376 1520 1760 1024 1025 1028 1085 +hsync +vsync
+    Modeline "GDM-1950"  109.62  1280 1336 1472 1720  1024 1024 1026 1062 -hsync -vsync
+       ModeLine     "1600x1000" 133.1 1600 1704 1872 2144 1000 1001 1004 1035 +hsync +vsync
+EndSection
+
+
+
+
+
+Section "Monitor"
+    Identifier  "Impression"
+    HorizSync   31.5 - 82.0
+    VertRefresh 50-100
+    Modeline "640x480@100" 43.163 640 680 744 848 480 481 484 509 +hsync +vsync
+    Modeline "1152x864@100" 143.472 1152 1232 1360 1568 864 865 868 915 +hsync +vsync
+       ModeLine     "1152x864@100" 143.5 1152 1232 1360 1568 864 865 868 915 +hsync +vsync
+EndSection
+
+
+
+Section "Modes"
+       Identifier     "Some mode for you"
+       ModeLine     "1920x1080" 172.8 1920 2040 2248 2576 1080 1081 1084 1118 -hsync -vsync
+       ModeLine     "2048x1536" 267.0 2048 2200 2424 2800 1536 1537 1540 1589 +hsync +vsync
+EndSection
+
+
+
+
+Section "Modes"
+       Identifier     "Other mode"
+       ModeLine     "1600x1000" 133.1 1600 1704 1872 2144 1000 1001 1004 1035 +hsync +vsync
+       ModeLine     "1920x2400@30" 149.2 1920 1928 1982 2044 2400 2402 2404 2434 +hsync +vsync
+EndSection
+
+
+
+
+
+Section "Device"
+       Identifier  "ATI Graphics Adapter"
+       Driver      "fglrx"
+       ChipId      0x0
+       ChipRev     0x0
+       Option      "BlockSignalsOnLock" "on"
+       Option      "Capabilities" "0x00000000"
+
+       Option      "CenterMode" "off"
+
+       Option      "DesktopSetup" "0x00000000"
+       Option      "FSAACustomizeMSPos" "no"
+       Option      "FSAADisableGamma" "no"
+       Option      "FSAAEnable" "no"
+       Option      "FSAAMSPosX0" "0.000000"
+       Option      "FSAAMSPosX1" "0.000000"
+       Option      "FSAAMSPosX2" "0.000000"
+       Option      "FSAAMSPosX3" "0.000000"
+       Option      "FSAAMSPosX4" "0.000000"
+       Option      "FSAAMSPosX5" "0.000000"
+       Option      "FSAAMSPosY0" "0.000000"
+       Option      "FSAAMSPosY1" "0.000000"
+       Option      "FSAAMSPosY2" "0.000000"
+       Option      "FSAAMSPosY3" "0.000000"
+       Option      "FSAAMSPosY4" "0.000000"
+       Option      "FSAAMSPosY5" "0.000000"
+
+       Option      "FSAAScale" "1"
+       Option      "ForceGenericCPU" "no"
+       Option      "GammaCorrectionI" "0x00000000"
+       Option      "GammaCorrectionII" "0x00000000"
+
+       Option      "HSync2" "unspecified"
+       Option      "IgnoreEDID" "off"
+       Option      "MonitorLayout" "AUTO, AUTO"
+       Option      "NoTV" "yes"
+       Option      "OpenGLOverlay" "off"
+
+       Option      "PseudoColorVisuals" "off"
+
+       Option      "ScreenOverlap" "0"
+
+       Option      "Stereo" "off"
+       Option      "StereoSyncEnable" "1"
+
+       Option      "TVColorAdj" "0"
+       Option      "TVHPosAdj" "0"
+       Option      "TVHSizeAdj" "0"
+       Option      "TVHStartAdj" "0"
+       Option      "TVStandard" "NTSC-M"
+       Option      "TVVPosAdj" "0"
+       Option      "TVVSizeAdj" "0"
+       Option      "UseFastTLS" "0"
+       Option      "UseInternalAGPGART" "no"
+       Option      "VRefresh2" "unspecified"
+       Option      "VideoOverlay" "on"
+
+       Option      "mtrr" "off" # disable DRI mtrr mapper, driver has its own code for mtrr
+
+       Option      "no_accel" "no"
+       Option      "no_dri" "no"
+
+       BusID       "PCI:2:0:0"
+       IRQ         0
+EndSection
+
+
+
+
+
+# Video Card #1, Matrox Millenium II PCI Video Card
+Section "Device"
+    Identifier  "Matrox"
+    Driver      "mga"
+    VideoRam 8192
+    BusID      "PCI:0:12:0"
+EndSection
+
+
+
+
+
+
+# Video Card # 2, Fire GL 1000 AGP video card.
+Section "Device"
+    Identifier  "FireGL"
+    Driver      "glint"
+    #VideoRam    8192
+    BusID      "PCI:1:0:0"
+
+EndSection
+
+
+
+
+Section "Screen"
+    Identifier  "Screen 2"
+    Device      "FireGL"
+    Monitor     "Impression"
+    DefaultDepth 16
+
+    Subsection "Display"
+        Depth       16
+        Modes       "1280x1024" "640x480"
+        ViewPort    0 0
+    EndSubsection
+EndSection
+
+
+
+
+# My Miniature monitor,  notice that I used the virtual option so it is
+#   the same heighth as the larger monitor,  this is not necessary.
+Section "Screen"
+    Identifier  "Screen 1"
+    Device      "Matrox"
+    Monitor     "Mini"
+    DefaultDepth 16
+
+    Subsection "Display"
+        Depth       16
+        Modes       "640x480"
+        ViewPort    0 0
+        Virtual     640 1024
+    EndSubsection
+EndSection
+
+
+
+
+
+Section "DRI"
+        Group        0
+        Mode         0666
+               Buffers      20 10 flag1
+               Buffers      40 30 flag2
+EndSection
+
diff -Naur xc.orig/programs/Xserver/Imakefile xc/programs/Xserver/Imakefile
--- xc.orig/programs/Xserver/Imakefile	2006-02-07 16:18:49.000000000 +0100
+++ xc/programs/Xserver/Imakefile	2006-02-07 16:41:36.000000000 +0100
@@ -319,6 +319,12 @@
 #endif
         SYSLIBS = $(ZLIB) MathLibrary Krb5Libraries $(DBMLIBS) $(USB) \
 		  $(PAMLIBS)  $(XAUTHLIB) $(XDMCPLIB) $(EXTRASYSLIBS)
+
+#if defined(UseElektra)
+ELEKTRA_LIBS=-L/lib -lelektra
+SYSLIBS += $(ELEKTRA_LIBS)
+#endif
+
 #if !HasCbrt
            CBRT = mi/LibraryTargetName(cbrt)
 #endif
