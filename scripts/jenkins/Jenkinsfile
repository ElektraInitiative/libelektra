// vim: ts=2:sw=2:expandtab:syntax=groovy
/* https://build.libelektra.org/job/elektra-jenkinsfile/
 * This file describes how the elektra-jenkinsfile buildjob should be
 * executed.
 *
 * 1. libraries and global variables are set
 * 2. define the main stages of the pipeline
 * 3. describe sub stages. This is where you will want to add new builds
 * 4. helper section to help write build scripts
 *
 * General Information about Jenkinsfiles can be found at
 * https://jenkins.io/doc/book/pipeline/jenkinsfile/.
 *
 * A Snippet generator is available to the public at
 * https://qa.nuxeo.org/jenkins/pipeline-syntax/.
 * A list of available commands on the build server can be found after a login at
 * https://build.libelektra.org/job/libelektra/pipeline-syntax/.
 */

// TODO have a per plugin/binding deps in Dockerfile for easier maintenance
// TODO add warnings plugins to scan for compiler warnings
//      Does appear to be not working for multiple runs in one job

// Libraries
@Library('libelektra-shared') _

// Buildjob properties
properties([
  buildDiscarder(
    logRotator(
      artifactDaysToKeepStr: '31',  // Keep artifacts for max 31 days
      artifactNumToKeepStr: '5',    // Keep artifacts for last 5 builds
      daysToKeepStr: '90',          // Keep build info for 90 days
      numToKeepStr: '60'            // Keep a max of 60 builds
    )
  )
])

// If previous run is still running, cancel it unless we are building
// code from the `master` branch.
abortPreviousRunUnlessMaster()

pipelineConfig {
// uncomment if you you want to overwrite these values
// dockerNodeLabel = 'docker'
// registry = 'hub.libelektra.org'
  now = new Date()
}

/* Define reusable cmake Flag globals
 *
 * They can be passed to many of the test helper functions and the cmake
 * function and represent flags usually passed to cmake.
 */
CMAKE_FLAGS_BASE = [
  'SITE': '${STAGE_NAME}',
  'KDB_DB_SYSTEM': '${WORKSPACE}/config/kdb/system',
  'KDB_DB_SPEC': '${WORKSPACE}/config/kdb/spec',
  'KDB_DB_HOME': '${WORKSPACE}/config/kdb/home',
  'CMAKE_INSTALL_PREFIX': '${WORKSPACE}/system',
  'BUILD_DOCUMENTATION': 'OFF',
  'CMAKE_RULE_MESSAGES': 'OFF',
  'COMMON_FLAGS': '-Werror'
]

CMAKE_FLAGS_BUILD_ALL = [
  'BINDINGS': 'ALL',
  'PLUGINS': 'ALL',
  'TOOLS': 'ALL'
]

CMAKE_FLAGS_COVERAGE = ['ENABLE_COVERAGE': 'ON']

CMAKE_FLAGS_CLANG = [
  'CMAKE_C_COMPILER': 'clang',
  'CMAKE_CXX_COMPILER': 'clang++'
]

CMAKE_FLAGS_MMAP = [
  'KDB_DB_FILE': 'default.mmap',
  'KDB_DB_INIT': 'elektra.mmap',
  'KDB_DEFAULT_STORAGE': 'mmapstorage'
]

CMAKE_FLAGS_I386 = [
  'CMAKE_C_FLAGS': '-m32',
  'CMAKE_CXX_FLAGS': '-m32'
]

CMAKE_FLAGS_ASAN = ['ENABLE_ASAN': 'ON']
CMAKE_FLAGS_DEBUG = ['ENABLE_DEBUG': 'ON']
CMAKE_FLAGS_LOGGER = ['ENABLE_LOGGER': 'ON']
CMAKE_FLAGS_OPTIMIZATIONS_OFF = ['ENABLE_OPTIMIZATIONS': 'OFF']
CMAKE_FLAGS_BUILD_TESTING_OFF = ['BUILD_TESTING': 'OFF']

// CMAKE_FLAGS_BUILD_SHARED = ['BUILD_SHARED': 'ON']  is ON per default
CMAKE_FLAGS_BUILD_FULL = ['BUILD_FULL': 'ON']
CMAKE_FLAGS_BUILD_STATIC = ['BUILD_STATIC': 'ON']

// Define TEST enum used in buildAndTest helper
enum TEST {
  MEM,        // Test for memoryleaks via valgrind
  NOKDB,      // Only run tests that do not write to disk
  ALL,        // Run all tests
  INSTALL,    // Run all tests on an installed version of Elektra
  CRYPTOS     // Test crypto, fcrypt and gpgme for memory leaks (quite unstable)
  public TEST() {}  // WORKAROUND https://issues.jenkins-ci.org/browse/JENKINS-33023
}

DOCKER_IMAGES = [:]  // Containers docker image descriptions, populated during
                     // dockerInit()

/*****************************************************************************
 * Main Stages
 *
 * Serial stages that contain parallelized logic. Only proceeds to the next
 * if previous stage did not fail.
 *****************************************************************************/

/* main function wrapping around all stages
 *
 * Added to improve readability.
 */
def main() {
  stage("Init docker images") {
    dockerInit()
  }

  stage("Pull docker images") {
    parallel dockerUtils.generateDockerPullStages(DOCKER_IMAGES)
  }

  maybeStage("Build docker images", DOCKER_IMAGES.any {img -> !img.value.exists}) {
    lock('docker-images') {
        parallel dockerUtils.generateDockerBuildStages(DOCKER_IMAGES)
    }
  }

  stage("Main builds") {
    milestone label: "Main builds"
    parallel generateMainBuildStages()
  }

  stage("Full builds") {
    milestone label: "Full builds"
    parallel generateFullBuildStages()
  }

  stage("Build artifacts") {
    milestone label: "Build artifacts"
    parallel generateArtifactStages()
  }

  maybeStage("Deploy Website", isMaster()) {
    milestone label: "Deploy Website"
    parallel deployWebsite()
  }

  // maybeStage("Deploy Web UI", isMaster()) {
  //   deployWebUI()
  // }
}

try {
  detectInterruption {
    main()
  }
} catch(UserInterruptedException uie) {
  println "Caught ${uie}"
} catch(Exception e) {
  if (isMaster()) {
    // If master is failing we want to know ASAP so send a mail.

    // collect changes since last build
    def changes = currentBuild.changeSets.collect() {
      it.collect() {
        "* ${it.getCommitId().take(7)} - ${it.getAuthor()} - ${it.getMsg().take(40)}"
      }.join('\n')
    }.join('\n')
    if (!changes) {
      changes = "* No new changes since last build"
    }

    def message = """\
Build ${JOB_NAME}:${BUILD_NUMBER} failed.
Url: ${RUN_DISPLAY_URL}
Reason: ${e}

Changes: ${RUN_CHANGES_DISPLAY_URL}
${changes}

Logs: ${currentBuild.rawBuild.getLog(20).join('\n')}
"""
    mail subject: "Build ${JOB_NAME} failed",
         body: message,
         replyTo: "noreply@libelektra.org",
         to: "build@libelektra.org"
  }
  throw e
}

/*****************************************************************************
 * Stage Generators
 *****************************************************************************/

/* Populate DOCKER_IMAGES with data
 *
 * For this we need a checkout of the scm to generate the hash for the
 * Dockerfiles which indicates if a rebuild of the images is needed
 */
def dockerInit() {
  node("master") {
    echo "Processing DOCKER_IMAGES"
    checkout scm

    /* We use the sid image for testing if we are compatible with Debian
     * unstable.
     * Additionally we use it for tests with Clang-6.0 and for source
     * formatting checks (as they depend on Clang-6.0).
     */
    DOCKER_IMAGES.sid = dockerUtils.createDockerImageDesc(
      "debian-sid", dockerUtils.&idTesting,
      "./scripts/docker/debian/sid",
      "./scripts/docker/debian/sid/Dockerfile"
    )

    /* Build Elektra's documentation with this image.
     * Also contains latex for pdf creation.
     */
    DOCKER_IMAGES.sid_doc = dockerUtils.createDockerImageDesc(
      "debian-sid-doc", dockerUtils.&idTesting,
      "./scripts/docker/debian/sid",
      "./scripts/docker/debian/sid/doc.Dockerfile"
    )

    /*
     * Debian Bullseye. Used for testing and packaging.
     */
    DOCKER_IMAGES.bullseye = dockerUtils.createDockerImageDesc(
      "debian-bullseye", dockerUtils.&idTesting,
      "./scripts/docker/debian/bullseye",
      "./scripts/docker/debian/bullseye/Dockerfile"
    )

    /* A minimal Debian Bullseye image used to test Elektra without any
     * additional requirements introduced by optional plugins, bindings,
     * ...
     */
    DOCKER_IMAGES.bullseye_minimal = dockerUtils.createDockerImageDesc(
      "debian-bullseye-minimal", dockerUtils.&idTesting,
      "./scripts/docker/debian/bullseye",
      "./scripts/docker/debian/bullseye/minimal.Dockerfile"
    )

    /* A Docker image for crossbuilding i386
     */
    DOCKER_IMAGES.bullseye_i386 = dockerUtils.createDockerImageDesc(
      "debian-bullseye-i386", dockerUtils.&idTesting,
      "./scripts/docker/debian/bullseye",
      "./scripts/docker/debian/bullseye/i386.Dockerfile"
    )

    /* Our main target for compatibility is Debian stable
     * (currently buster).
     * Hence we try to build all parts of Elektra via this image.
     * Most of the tests defined below use this image.
     * Especially noteworthy is that this image is also used for Debian
     * package building
     */
    DOCKER_IMAGES.buster = dockerUtils.createDockerImageDesc(
      "debian-buster", dockerUtils.&idTesting,
      "./scripts/docker/debian/buster",
      "./scripts/docker/debian/buster/Dockerfile"
    )

    /* A minimal Debian buster image used to test Elektra without any
     * additional requirements introduced by optional plugins, bindings,
     * ...
     */
    DOCKER_IMAGES.buster_minimal = dockerUtils.createDockerImageDesc(
      "debian-buster-minimal", dockerUtils.&idTesting,
      "./scripts/docker/debian/buster",
      "./scripts/docker/debian/buster/minimal.Dockerfile"
    )

    /* A Docker image for crossbuilding i386
     */
    DOCKER_IMAGES.buster_i386 = dockerUtils.createDockerImageDesc(
      "debian-buster-i386", dockerUtils.&idTesting,
      "./scripts/docker/debian/buster",
      "./scripts/docker/debian/buster/i386.Dockerfile"
    )

    /* A Debian oldstable image used for testing backwards compatibility.
     */
    DOCKER_IMAGES.stretch = dockerUtils.createDockerImageDesc(
      "debian-stretch", dockerUtils.&idTesting,
      "./scripts/docker/debian/stretch",
      "./scripts/docker/debian/stretch/Dockerfile"
    )

    /* A minimal Debian stretch image used to test Elektra without any
     * additional requirements introduced by optional plugins, bindings,
     * ...
     */
    DOCKER_IMAGES.stretch_minimal = dockerUtils.createDockerImageDesc(
      "debian-stretch-minimal", dockerUtils.&idTesting,
      "./scripts/docker/debian/stretch",
      "./scripts/docker/debian/stretch/minimal.Dockerfile"
    )

    /* A Docker image for crossbuilding i386
     */
    DOCKER_IMAGES.stretch_i386 = dockerUtils.createDockerImageDesc(
      "debian-stretch-i386", dockerUtils.&idTesting,
      "./scripts/docker/debian/stretch",
      "./scripts/docker/debian/stretch/i386.Dockerfile"
    )

    /* Ubuntu xenial image used to test compatibility with Ubuntu.
     */
    DOCKER_IMAGES.xenial = dockerUtils.createDockerImageDesc(
      "ubuntu-xenial", dockerUtils.&idTesting,
      "./scripts/docker/ubuntu/xenial",
      "./scripts/docker/ubuntu/xenial/Dockerfile"
    )

    /* Alpine: used to compile against musl and uses ash as shell
     */
    DOCKER_IMAGES.alpine = dockerUtils.createDockerImageDesc(
      "alpine", dockerUtils.&idTesting,
      "./scripts/docker/alpine/3.14",
      "./scripts/docker/alpine/3.14/Dockerfile"
    )

    /* Ubuntu bionic image*/
    DOCKER_IMAGES.bionic = dockerUtils.createDockerImageDesc(
      "bionic", dockerUtils.&idTesting,
      "./scripts/docker/ubuntu/bionic",
      "./scripts/docker/ubuntu/bionic/Dockerfile"
    )

    /* Ubuntu bionic image*/
    DOCKER_IMAGES.focal = dockerUtils.createDockerImageDesc(
      "focal", dockerUtils.&idTesting,
      "./scripts/docker/ubuntu/focal",
      "./scripts/docker/ubuntu/focal/Dockerfile"
    )

    /* Fedora 33 image*/
    DOCKER_IMAGES.fedora_33 = dockerUtils.createDockerImageDesc(
      "fedora-33", dockerUtils.&idTesting,
      "./scripts/docker/fedora/33",
      "./scripts/docker/fedora/33/Dockerfile"
    )

    /* Fedora 34 image*/
    DOCKER_IMAGES.fedora_34 = dockerUtils.createDockerImageDesc(
      "fedora-34", dockerUtils.&idTesting,
      "./scripts/docker/fedora/34",
      "./scripts/docker/fedora/34/Dockerfile"
    )

    /* Image building the libelektra.org website */
    DOCKER_IMAGES.website = dockerUtils.createDockerImageDesc(
      "website", dockerUtils.&idArtifact,
      ".",
      "./scripts/docker/website/Dockerfile",
      false
    )

    /* Image building elektra web base image */
    DOCKER_IMAGES.webui_base = dockerUtils.createDockerImageDesc(
      "web-base", dockerUtils.&idArtifact,
      ".",
      "./scripts/docker/webui/base/Dockerfile",
      false
    )

    /* Image building elektrad */
    DOCKER_IMAGES.webui_elektrad = dockerUtils.createDockerImageDesc(
      "elektrad-demo", dockerUtils.&idArtifact,
      "./scripts/docker/webui/elektrad-demo/",
      "./scripts/docker/webui/elektrad-demo/Dockerfile",
      false
    )

    /* Image building webd */
    DOCKER_IMAGES.webui_webd = dockerUtils.createDockerImageDesc(
      "webd-demo", dockerUtils.&idArtifact,
      "./scripts/docker/webui/webd-demo/",
      "./scripts/docker/webui/webd-demo/Dockerfile",
      false
    )

    /* Debian buster image used to install previously built packages */
    DOCKER_IMAGES.buster_installed = dockerUtils.createDockerImageDesc(
      "debian-buster-installed", dockerUtils.&idArtifact,
      "./build/package",
      "./scripts/docker/debian/buster/release.Dockerfile",
      false
    )

    /* Debian bullseye image used to install previously built packages */
    DOCKER_IMAGES.bullseye_installed = dockerUtils.createDockerImageDesc(
      "debian-bullseye-installed", dockerUtils.&idArtifact,
      "./build/package",
      "./scripts/docker/debian/bullseye/release.Dockerfile",
      false
    )

    /* Ubuntu focal image used to install previously built packages */
    DOCKER_IMAGES.focal_installed = dockerUtils.createDockerImageDesc(
      "ubuntu-focal-installed", dockerUtils.&idArtifact,
      "./build/package",
      "./scripts/docker/ubuntu/focal/release.Dockerfile",
      false
    )

    /* Ubuntu bionic image used to install previously built packages */
    DOCKER_IMAGES.bionic_installed = dockerUtils.createDockerImageDesc(
      "ubuntu-bionic-installed", dockerUtils.&idArtifact,
      "./build/package",
      "./scripts/docker/ubuntu/bionic/release.Dockerfile",
      false
    )

    /* Fedora 33 image used to install previously built packages */
    DOCKER_IMAGES.fedora_33_installed = dockerUtils.createDockerImageDesc(
      "fedora-33-installed", dockerUtils.&idArtifact,
      "./build/package",
      "./scripts/docker/fedora/33/release.Dockerfile",
      false
    )

    /* Fedora 34 image used to install previously built packages */
    DOCKER_IMAGES.fedora_34_installed = dockerUtils.createDockerImageDesc(
      "fedora-34-installed", dockerUtils.&idArtifact,
      "./build/package",
      "./scripts/docker/fedora/34/release.Dockerfile",
      false
    )
  }
}

/* Generate Main stages
 *
 * Should be used to give quick feedback to developer and check for obvious
 * errors before the intensive tasks start
 */
def generateMainBuildStages() {
  def tasks = [:]
  // We want fo fail fast (i.e. abort parallel stages if one fails
  tasks.failFast = true


  // Add a task that should build the whole project to catch all test errors
  // in a standard environment
  tasks << buildAndTest(
    "debian-bullseye-full",
    DOCKER_IMAGES.bullseye,
    CMAKE_FLAGS_BUILD_ALL +
      CMAKE_FLAGS_DEBUG +
      CMAKE_FLAGS_BUILD_FULL +
      CMAKE_FLAGS_BUILD_STATIC +
      CMAKE_FLAGS_COVERAGE
    ,
    [TEST.ALL, TEST.MEM, TEST.NOKDB, TEST.INSTALL]
  )


  return tasks
}

/* Generate Test stages for full test coverage
 */
def generateFullBuildStages() {
  def tasks = [:]


  // Build Elektra on debian bullseye
  tasks << buildAndTest(
    "debian-bullseye-full",
    DOCKER_IMAGES.bullseye,
    CMAKE_FLAGS_BUILD_ALL+
    CMAKE_FLAGS_DEBUG,
    [TEST.ALL, TEST.MEM, TEST.INSTALL]
  )

  // Build Elektra on a minimal Debian Bullseye Docker image
  tasks << buildAndTest(
    "debian-bullseye-minimal",
    DOCKER_IMAGES.bullseye_minimal,
    [:],
    [TEST.ALL]
  )

  // Build Elektra on a minimal Debian Bullseye Docker image
  // specify NODEP and see if plugins are properly included/excluded
  tasks << buildAndTest(
    "debian-bullseye-minimal-nodep",
    DOCKER_IMAGES.bullseye_minimal,
    ['PLUGINS': 'NODEP'],
    [TEST.ALL]
  )

  // Build Elektra without the cache plugin
  tasks << buildAndTest(
    "debian-bullseye-full-nocache",
    DOCKER_IMAGES.bullseye,
    CMAKE_FLAGS_BUILD_ALL +
      CMAKE_FLAGS_DEBUG +
      CMAKE_FLAGS_COVERAGE + [
      'PLUGINS': 'ALL;-DEPRECATED;-cache',
      ],
    [TEST.ALL, TEST.MEM]
  )


  // Build Elektra without tests
  tasks << buildAndTest(
    "debian-bullseye-full-build-testing-off",
    DOCKER_IMAGES.bullseye,
    CMAKE_FLAGS_BUILD_ALL +
      CMAKE_FLAGS_BUILD_TESTING_OFF
    ,
    []
  )


  return tasks
}

/* Stage for analysing open Tasks and running sloccount */
def buildTodo() {
  def stageName = "todo"
  def openTaskPatterns = '''\
**/*.c, **/*.h, **/*.hpp, **/*.cpp,\
**/CMakeLists.txt, **/Dockerfile*, Jenkinsfile*
'''
  return [(stageName): {
    stage(stageName) {
      withDockerEnv(DOCKER_IMAGES.sid_doc) {
        sh "sloccount --duplicates --wide --details ${WORKSPACE} > sloccount.sc"
        step([$class: 'SloccountPublisher', ignoreBuildFailure: true])
        recordIssues(tools: [taskScanner(ignoreCase: true, includePattern: openTaskPatterns, lowTags: 'TODO,FIXME')])
        utils.archive(["sloccount.sc"])
        deleteDir()
      }
    }
  }]
}

/* Stage checking if release notes have been updated */
def buildCheckReleaseNotes() {
  def stageName = "check-release-notes"
  return [(stageName): {
    maybeStage(stageName, !isMaster()) {
      withDockerEnv(DOCKER_IMAGES.bullseye, [DockerOpts.MOUNT_MIRROR]) {
        sh "scripts/build/run_check_release_notes"
        deleteDir()
      }
    }
  }]
}

/* Stage running Icheck to see if the API has been modified */
def buildIcheck() {
  def stageName = "icheck"
  return [(stageName): {
    stage(stageName) {
      withDockerEnv(DOCKER_IMAGES.bullseye, [DockerOpts.MOUNT_MIRROR]) {
        sh "scripts/build/run_icheck"
        deleteDir()
      }
    }
  }]
}

def buildFormatChecks() {
  def stageName = "formatting-check"
  return [(stageName): {
    stage(stageName) {
      withDockerEnv(DOCKER_IMAGES.sid, [DockerOpts.MOUNT_MIRROR]) {
        dir('build') {
          deleteDir()
          utils.cmake(env.WORKSPACE, [:])
          ctest("Test -R testscr_check_formatting")
        }
      }
    }
  }]
}

/* Stage building and uploading the documentation */
def buildDoc() {
  def stageName = "doc"
  cmakeFlags = [
    'BUILD_PDF': 'ON',
    'BUILD_FULL': 'OFF',
    'BUILD_SHARED': 'OFF',
    'BUILD_STATIC': 'OFF',
    'BUILD_TESTING': 'OFF'
  ]
  return [(stageName): {
    stage(stageName) {
      withDockerEnv(DOCKER_IMAGES.sid_doc) {
        dir('build') {
          deleteDir()
          utils.cmake(env.WORKSPACE, cmakeFlags)
          sh "make html latex man pdf"
        }

        def apib = "./doc/api_blueprints/snippet-sharing.apib"
        def apiDocDir = "./build/API_DOC/restapi"
        sh "mkdir -p ${apiDocDir}/${VERSION}"
        sh "cp ${apib} ${apiDocDir}/${VERSION}/"
        apiary(apib, "${apiDocDir}/${VERSION}/snippet-sharing.html")
        dir(apiDocDir) {
          sh "ln -s ${VERSION} current"
        }

        recordIssues(tools: [doxygen(pattern: 'build/doc/doxygen.log')])

        def uploadDir = "api/${env.BRANCH_NAME}"
        if (!isMaster()) {
          uploadDir = "api/pr/${env.BRANCH_NAME}"
        }
        sshPublisher(
          publishers: [
            sshPublisherDesc(
              verbose: true,
              configName: 'doc.libelektra.org',
              transfers: [
                sshTransfer(
                  sourceFiles: 'build/doc/latex/*',
                  removePrefix: 'build/doc/',
                  remoteDirectory: "${uploadDir}"
                ),
                sshTransfer(
                  sourceFiles: 'build/doc/html/*',
                  removePrefix: 'build/doc/',
                  remoteDirectory: "${uploadDir}"
                ),
                sshTransfer(
                  sourceFiles: 'build/doc/man/man3elektra/*',
                  removePrefix: 'build/doc/man/man3elektra/',
                  remoteDirectory: "${uploadDir}/man"
                )
              ]
            )
          ]
        )
        deleteDir()
      }
    }
  }]
}

/* Helper to generate an asan enabled test */
def buildAndTestAsan(testName, image, extraCmakeFlags = [:]) {
  def cmakeFlags = CMAKE_FLAGS_BASE +
                   CMAKE_FLAGS_ASAN +
                   extraCmakeFlags
  def dockerOpts = [DockerOpts.MOUNT_MIRROR, DockerOpts.PTRACE]
  return [(testName): {
    stage(testName) {
      withDockerEnv(image, dockerOpts) {
        dir('build') {
          deleteDir()
          utils.cmake(env.WORKSPACE, cmakeFlags)
          sh "make"
          def llvm_symbolizer = sh(returnStdout: true,
                                   script: 'which llvm-symbolizer').trim()
          withEnv(["ASAN_OPTIONS='symbolize=1'",
                   "ASAN_SYMBOLIZER_PATH=${llvm_symbolizer}"]){
            ctest()
          }
        }
      }
    }
  }]
}

/* Helper to generate mingw test */
def buildAndTestMingwW64() {
  def testName = "debian-bullseye-mingw-w64"
  return [(testName): {
    stage(testName) {
      withDockerEnv(DOCKER_IMAGES.bullseye) {
        dir('build') {
          deleteDir()
          sh '../scripts/dev/configure-mingw-w64 ..'
          sh 'make'
          def destdir='elektra'
          withEnv(["DESTDIR=${destdir}"]){
              sh 'make install'
          }
          sh "zip -r elektra.zip ${destdir}"
          utils.archive(['elektra.zip'])
        }
      }
    }
  }]
}

/* Helper to generate a typical Elektra test environment
 *   Builds Elektra, depending on the contents of 'tests' it runs the
 *   corresponding test suites.
 * testName: used to identify the test and name the stage
 * image: which docker image should be used
 * extraCmakeFlags: which flags should be passed to cmake
 * tests: list of tests (see TEST enum) which should be run
 * extraArtifacts: which files should be additionally saved from the build
 */
def buildAndTest(testName, image, extraCmakeFlags = [:],
                 tests = [], extraArtifacts = []) {
  def cmakeFlags = CMAKE_FLAGS_BASE + extraCmakeFlags
  def artifacts = []

  def testCoverage = cmakeFlags.intersect(CMAKE_FLAGS_COVERAGE)
                                .equals(CMAKE_FLAGS_COVERAGE)
  def updateCoveralls = testName == 'debian-bullseye-full'
  def testMem = tests.contains(TEST.MEM)
  def testNokdb = tests.contains(TEST.NOKDB)
  def testAll = tests.contains(TEST.ALL)
  def testCryptos = tests.contains(TEST.CRYPTOS)
  def install = tests.contains(TEST.INSTALL)
  def dockerOpts = [DockerOpts.MOUNT_MIRROR]
  return [(testName): {
    stage(testName) {
      withDockerEnv(image, dockerOpts) {
        // we use a space in the directory to test if paths are
        // properly escaped
        def buildDir='build directory'

        if(tests) {
          artifacts.add("\"${buildDir}\"/Testing/*/*.xml")
        }

        try {
          ensureDirsExist(getElektraWritableFiles())

          dir(buildDir) {
            deleteDir()
            utils.cmake(env.WORKSPACE, cmakeFlags)
            sh "make"
            trackCoverage(testCoverage) {
              if(testAll) {
                ctest()
                if(testMem) {
                  cmemcheck()
                }
              }
              if(testNokdb) {
                withPermissions(getElektraWritableFiles(), "000") {
                  cnokdbtest()
                  if(testMem && !testAll) {
                    cmemcheck(testNokdb)
                  }
                }
              }
              if(testCryptos) {
                ctestcryptoplugins()
              }
            }
            if(install) {
              sh 'make install'
            }
          }
          if(install) {
            sh '''\
export LD_LIBRARY_PATH=${WORKSPACE}/system/lib:$LD_LIBRARY_PATH
export PATH=${WORKSPACE}/system/bin:$PATH
export DBUS_SESSION_BUS_ADDRESS=`dbus-daemon --session --fork --print-address`
export LUA_CPATH="${WORKSPACE}/system/lib/lua/5.2/?.so;"

env

kdb run_all
kill `pidof dbus-daemon` || echo "No dbus-daemon to kill."
'''
          }
        } catch(e) {
          println "Caught the following exception: ${e.message}"
          // rethrow to mark as failed
          throw e
        } finally {
          /* Warnings plugin overwrites each other, disable for now
          warnings canRunOnFailed: true, consoleParsers: [
            [parserName: 'GNU Make + GNU C Compiler (gcc)']
          ]
          */
          utils.archive(artifacts)
          if(testCoverage) {
            publishCoverage("${buildDir}/coverage")
          }
          if(updateCoveralls) {
            withCredentials([string(credentialsId: 'coveralls-repo-token', variable: 'REPO_TOKEN')]) {
              withEnv(["TRAVIS_JOB_ID=$BUILD_NUMBER"]) {
                sh("""\
coveralls -b '${buildDir}' \
          -t '${REPO_TOKEN}' \
          -e .idea -e benchmarks -e doc -e examples -e install -e libelektra -e system -e tests \
          -E '.*${buildDir}/(CMakeFiles|include)/.*' \
          -E '.*${buildDir}/src/bindings/(glib|intercept)/.*' \
          -E '.*${buildDir}/src/include/elektra/.*' \
          -E '.*${buildDir}/src/include/(kdb|kdbconfig|kdbversion)\\.h' \
          -E '.*${buildDir}/src/(libs|tools)/.*' \
          -E '.*${buildDir}/src/plugins/\
(?!\
constants/constants\\.c|\
(lua|ruby)/runtime\\.h
).*' \
          -E '.*/src/error/.*' \
""")
              }
            }
          }
          if(testMem || testNokdb || testAll) {
            xunitUpload("${buildDir}/Testing/**/*.xml")
          }
          deleteDir()
        }
      }
    }
  }]
}

/**
 *  Generate Stages that build, test and deploy artifacts
 */
def generateArtifactStages() {
  def tasks = [:]

  tasks << buildPackage(
    "buildPackage/debian/bullseye",
    DOCKER_IMAGES.bullseye,
    "bullseye-unstable",
    "bullseye",
    DOCKER_IMAGES.bullseye_installed,
    release.&publishDebPackages,
    this.&updateDebianChangelog
  )

  return tasks
}


/**
 *  Runs the packaging script, tests packages and publishes to unstable repo.
 *
 * `withDockerEnv` accepts a second closure that builds the test image,
 * tests packages and publishes them. This is necessary to ensure that
 * these steps are run on the same node with the same working directory.
 *
 * @param stageName e.g. buildPackage/debian/<codename>
 * @param image must be one of DOCKER_IMAGES
 * @param repoName name of the package repository
 * @param repoPrefix prefix of the package repository
 * @param installImage image which should be build containing the built packages
 * @param publishPackagesFun Closure that publishes packages to a repository
 * @param updateChangelogFun Closure that updates the changelog
 * @param placeholderDir Bool that describes if placeholder dirs need to be created
 */
def buildPackage(stageName, image, repoName, repoPrefix, installImage,
                 publishPackagesFun, updateChangelogFun,
                 placeholderDir=false) {
  return [(stageName): {
    stage(stageName) {
      def packageRevision = ''
      def targetDir=""
      if (placeholderDir) {
        // necessary because libelektra path must be longer than
        // CPACK_RPM_<component>_BUILD_SOURCE_DIRS_PREFIX for debuginfo generation
        // of RPM packages.
        targetDir = "./placeholder/placeholder/placeholder/placeholder/libelektra"
      } else {
        targetDir = "./libelektra"
      }
      // Closure that builds the image with the previously generated packages,
      // tests these packages and publishes them.
      def postCl = {
        dir(targetDir) {
          // during the buildImage step the packages are installed and kdb run_all is executed
          dockerUtils.buildImage(installImage)
          dir("build/package") {
            if (isMaster()) {
              publishPackagesFun(
                'doc.libelektra.org',
                "/packaging/incoming/${repoName}/",
                repoName,
                repoPrefix,
                "$VERSION",
                packageRevision,
                targetDir
              )
            }
          }
        }
      }
      withDockerEnv(image, [DockerOpts.MOUNT_MIRROR, DockerOpts.NO_CHECKOUT], postCl) {
        withCredentials([file(credentialsId: 'jenkins-key', variable: 'KEY'),
                         file(credentialsId: 'jenkins-secret-key', variable: 'SKEY')]) {
          sh "gpg --import $KEY"
          sh "gpg --import $SKEY"
          checkout scm: [
            $class: 'GitSCM',
            branches: scm.branches,
            extensions: scm.extensions + [
              [$class: 'PerBuildTag'],
              [$class: 'RelativeTargetDirectory',
               relativeTargetDir: targetDir]
            ],
            userRemoteConfigs: scm.userRemoteConfigs
          ]
          dir(targetDir) {
            sh "git config --global user.name jenkins-builder"
            sh "git config --global user.email jenkins@libelektra.org"

            dir('scripts/packaging') {
              packageRevision = updateChangelogFun()
            }

            dir("build") {
              sh "../scripts/packaging/package.sh ${packageRevision}"
              sh "../scripts/release/sign-packages.sh ./package"
            }
          }
        }
      }
    }
  }]
}

/**
 * Updates the fedora changelog for the unstable build
 * @return revision number of the package
 */
def updateFedoraChangelog() {
  dir ("fedora") {
    sh "./update-rpm-changelog.sh -l '.$BUILD_NUMBER' -m 'auto build'"
    sh "git commit -am 'auto build $VERSION'"
    return sh(
      returnStdout: true,
      script: './update-rpm-changelog.sh -p | cut -d "-" -f2'
    ).trim()
  }
}

/**
 * Updates the ubuntu changelog for the unstable build
 * @return revision number of the package
 */
def updateDebianChangelog() {
  sh "dch -l '.$BUILD_NUMBER' 'auto build'"
  sh "git commit -am 'auto build $VERSION'"
  return sh(
    returnStdout: true,
    script: 'dpkg-parsechangelog --show-field Version -l ./debian/changelog | cut -d "-" -f2'
  ).trim()
}


def deployDockerContainer(name, imageDesc, hostName) {
  node("frontend") {
    docker.withRegistry("https://${PipelineConfig.instance.registry}",
                        'docker-hub-elektra-jenkins') {
      def img = docker.image(imageDesc.id)
      img.pull()

      sh "docker stop -t 5 ${name} || /bin/true"
      sh "docker rm ${name} || /bin/true"
      img.run("""\
        -e VIRTUAL_HOST=${hostName} \
        -e LETSENCRYPT_HOST=${hostName} \
        -e LETSENCRYPT_EMAIL=jenkins@hub.libelektra.org \
        --name ${name} \
        --network=frontend_default \
        --restart=always"""
      )
    }
  }
}

def buildWebsite() {
  def websiteTasks = [:]
  websiteTasks << dockerUtils.buildImageStage(DOCKER_IMAGES.website)
  return websiteTasks
}

def deployWebsite() {
  def deployTasks = [:]
  deployTasks << release.deployWebsite(DOCKER_IMAGES.website)
  return deployTasks
}

def deployWebUI() {
  deployDockerContainer(
    "elektrad",
    DOCKER_IMAGES.webui_elektrad,
    "elektrad-demo.libelektra.org"
  )
  deployDockerContainer(
    "webd",
    DOCKER_IMAGES.webui_webd,
    "webdemo.libelektra.org"
  )
}

def buildWebUI() {
  def webuiTasks = [:]
  webuiTasks << dockerUtils.buildImageStage(DOCKER_IMAGES.webui_elektrad)
  webuiTasks << dockerUtils.buildImageStage(DOCKER_IMAGES.webui_webd)
  return webuiTasks
}

/*****************************************************************************
 * Define helper functions
 *****************************************************************************/

/* Publishes coverage reports
 * @param source dir where coverage reports are located
 */
def publishCoverage(source = 'build/coverage') {
  echo "Start publication of coverage data"
  def uploadDir = "coverage/${env.BRANCH_NAME}/${env.STAGE_NAME}"
  def archiveName = "cov_${env.BRANCH_NAME}_${env.STAGE_NAME}.tar.gz"

  sh "mkdir -p ${uploadDir}"
  sh "mv -v -T '${source}' ${uploadDir} || /bin/true"
  sh "tar -czvf ${archiveName} ${uploadDir}"

  sshPublisher(
    publishers: [
      sshPublisherDesc(
        verbose: true,
        configName: 'doc.libelektra.org',
        transfers: [
          sshTransfer(
            sourceFiles: archiveName,
            execCommand: "cd /srv/libelektra && tar -zxvf ${archiveName} && rm ${archiveName}"
          )
        ]
      )
    ]
  )
  echo "Finish publication of coverage data"
}

/* Track coverage
 *
 * Tracks coverage of commands executed in the passed closure if do_track
 * evaluates to true.
 * @param doTrack If true track coverage
 * @param cl A closure that this function wraps around
 */
def trackCoverage(doTrack, cl) {
  if(doTrack) {
    sh 'make coverage-start'
  }
  cl()
  if(doTrack) {
    sh 'make coverage-stop'
    sh 'make coverage-genhtml'
  }
}

/* Run ctest with appropriate env variables
 * @param target What target to pass to ctest
 */
def ctest(target = "Test") {
  /*
     We disable the tests:

     - `testmod_dbus`,
     - `testmod_dbusrecv`,and
     - `testmod_zeromqsend`

     , since they are known to fail in scenarios with high load.
     See also: https://issues.libelektra.org/2439
  */
  sh """ctest -j ${env.CTEST_PARALLEL_LEVEL} --force-new-ctest-process \
          --output-on-failure --no-compress-output -T ${target} \
          -E 'testmod_(dbus(recv)?|zeromqsend)'"""
}

/* Helper for ctest to run MemCheck for the crypto, fcrypt and gpgme plugin
 * tests, which cause trouble when run in parallel or under high server load.
 */
def ctestcryptoplugins(target = "MemCheck") {
  sh """ctest --force-new-ctest-process \
        --output-on-failure --no-compress-output -T ${target} \
        -R 'testmod_(crypto|fcrypt|gpgme)'"""
}

/* Helper for ctest to run MemCheck without memleak tagged tests
 * @param kdbtests If true run tests tagged as kdbtests
 */
def cmemcheck(kdbtests=true) {
  if(kdbtests) {
    ctest("MemCheck -LE memleak")
  } else {
    ctest("MemCheck -LE memleak||kdbtests")
  }
}

/* Helper for ctest to run tests without tests tagged as kdbtests.
 */
def cnokdbtest() {
  ctest("Test -LE kdbtests")
}

/* Uploads ctest results
 * @param p Pattern to scan for
 */
def xunitUpload(p = 'build/Testing/**/*.xml') {
  step([$class: 'XUnitPublisher',
    thresholds: [
      [$class: 'SkippedThreshold', failureThreshold: '0'],
      [$class: 'FailedThreshold', failureThreshold: '0']
    ],
    tools: [
      [$class: 'CTestType', pattern: p]
    ]
  ])
}

/* Returns True if we are on the master branch
 */
def isMaster() {
  return env.BRANCH_NAME=="master"
}

/* Run apiary
 * @param input Input file (.apib)
 * @param output Output file (.html)
 */
def apiary(input, output) {
  sh "apiary preview --path=${input} --output=${output}"
}

def abortPreviousRunUnlessMaster() {
  // We never want to abort builds of the master branch
  if (isMaster()) return;
  def exec = currentBuild
             ?.rawBuild
             ?.getPreviousBuildInProgress()
             ?.getExecutor()
  if(exec) {
    exec.interrupt(
      Result.ABORTED,
      new CauseOfInterruption.UserInterruption(
        "Aborted by Build#${currentBuild.number}"
      )
    )
  }
}

/* Helper that modifies file permissions before executing the passed closure.
 * Restores the permissions after the closure has run.
 * @param listOfFiles List representing directories and files that should be
 *                    made unwritable.
 *                    Files must exist or it will fail.
 * @param perm target permissions in a form that can be passed to chmod
 * @param cl The closure that should be run
 */
def withPermissions(listOfFiles, perm, cl) {
  echo "Entering withPermissions"
  permissionsMap = [:]
  listOfFiles.each {
    def permOld = getPermissions(it)
    permissionsMap[it] = permOld
    setPermissions(it, perm)
  }
  try {
    cl()
  } catch (all) {
    // rethrow to mark as failed
    throw all
  } finally {
    // always restore permissions
    permissionsMap.each {
        setPermissions(it.key, it.value)
    }
    echo "Leaving withPermissions"
  }
}

/* Returns the permissions of a file via stat
 * @param file The file to get the permissions for
 */
def getPermissions(file) {
  return sh(returnStdout: true, script: "stat -c %a $file").trim()
}

/* Set permissions of a file
 * @param file The file to set the permissions for
 * @param mode permissions to set for the file
 */
def setPermissions(file, mode) {
  return sh(returnStdout: true, script: "chmod $mode $file")
}

/* Helper that returns files and directories elektra tests could write to
 */
def getElektraWritableFiles() {
  return [
    CMAKE_FLAGS_BASE.get('KDB_DB_SYSTEM'),
    CMAKE_FLAGS_BASE.get('KDB_DB_SPEC'),
    CMAKE_FLAGS_BASE.get('KDB_DB_HOME')
  ]
}

/* Create directories in listOfDirs
 * @param listOfDirs a List of directory paths to be created
 */
def ensureDirsExist(listOfDirs) {
  listOfDirs.each {
    sh "mkdir -p $it || /bin/true"
  }
}


/* Detect if pipeline was aborted
 *
 * Depending on which part of the pipeline was interrupted a different Exception
 * is thrown. This wrapper makes sure a UserInterruptedException is thrown
 * regardless of pipeline state.
 *
 * see: https://issues.jenkins-ci.org/browse/JENKINS-34376
 */
def detectInterruption(Closure c) {
  try {
    c()
  } catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException fie) {
    // this ambiguous condition means a user probably aborted
    if (!fie.message) {
        throw new UserInterruptedException(fie)
    } else {
        throw fie
    }
  } catch (hudson.AbortException ae) {
    // this ambiguous condition means during a shell step, user probably aborted
    if (ae.getMessage().contains('script returned exit code 143') ||
        ae.getMessage().contains('Queue task was cancelled')) {
        throw new UserInterruptedException(ae)
    } else {
        throw ae
    }
  }
}

class UserInterruptedException extends Exception {
    UserInterruptedException(e) {
        super(e)
    }
}
