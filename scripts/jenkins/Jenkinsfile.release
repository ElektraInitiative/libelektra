#!/usr/bin/env groovy

// Libraries
@Library('libelektra-shared') _

// Buildjob properties
properties([
  buildDiscarder(
    logRotator(
      artifactDaysToKeepStr: '31',
      artifactNumToKeepStr: '10'
    )
  ),
  parameters([
    booleanParam(
      defaultValue: false,
      description: 'If activated, the documentation is generated.',
      name: 'generate_docu'
    ),
    string(
      defaultValue: '1',
      description: 'Debian package revision.',
      name: 'debian_revision',
      trim: true
    ),
    string(
      defaultValue: '1',
      description: 'Ubuntu package revision.',
      name: 'ubuntu_revision',
      trim: true
    ),
    string(
      defaultValue: '1',
      description: 'Fedora package revision.',
      name: 'fedora_revision',
      trim: true
    )
  ])
])

pipelineConfig {
// uncomment if you you want to overwrite these values
// dockerNodeLabel = 'docker'
// registry = 'hub.libelektra.org'
  now = new Date()
}


DOCKER_IMAGES = [:]  // Containers docker image descriptions, populated during
                     // dockerInit()

RELEASE_VERSION = '' // release version, set during release build and used
                     // by the documentation stage


// Stages
stage("Init docker images") {
  dockerInit()
}

stage("Pull docker images") {
  parallel dockerUtils.generateDockerPullStages(DOCKER_IMAGES)
}

maybeStage("Build docker images", DOCKER_IMAGES.any {img -> !img.value.exists}) {
  lock('docker-images') {
        parallel dockerUtils.generateDockerBuildStages(DOCKER_IMAGES)
    }
}

stage("Release") {
  milestone label: "Release"
  parallel generateReleaseStages()
}


stage("Build docker images for package testing") {
  parallel generateDockerBuildStagesWithPackagesInstalled()
}

stage("Test packages") {
  parallel generateInstalledPackagesTestStages()
}

// Pause pipeline and wait for approval to run publishsing steps
input(message: 'Publish Release?', ok: 'Yes')

stage("Publish") {
  sequential generatePublishStages()
}



/**************/
/* Generators */
/**************/

/* Populate DOCKER_IMAGES with data
 *
 * For this we need a checkout of the scm to generate the hash for the
 * Dockerfiles which indicates if a rebuild of the images is needed
 */
def dockerInit() {
  node("master") {
    echo "Processing DOCKER_IMAGES"
    checkout scm

    // Test and build release artifacts with these images.
    DOCKER_IMAGES.buster = dockerUtils.createDockerImageDesc(
      "debian-buster", dockerUtils.&idTesting,
      "./scripts/docker/debian/buster",
      "./scripts/docker/debian/buster/Dockerfile"
    )

    DOCKER_IMAGES.focal = dockerUtils.createDockerImageDesc(
      "ubuntu-focal", dockerUtils.&idTesting,
      "./scripts/docker/ubuntu/focal",
      "./scripts/docker/ubuntu/focal/Dockerfile"
    )

    DOCKER_IMAGES.bionic = dockerUtils.createDockerImageDesc(
      "ubuntu-bionic", dockerUtils.&idTesting,
      "./scripts/docker/ubuntu/bionic",
      "./scripts/docker/ubuntu/bionic/Dockerfile"
    )

    DOCKER_IMAGES.fedora_33 = dockerUtils.createDockerImageDesc(
      "fedora-33", dockerUtils.&idTesting,
      "./scripts/docker/fedora/33",
      "./scripts/docker/fedora/33/Dockerfile"
    )

    // Insta and test the built packages with theses images.
    DOCKER_IMAGES.buster_installed = dockerUtils.createDockerImageDesc(
      "debian-buster-installed", dockerUtils.&idTesting,
      "./release-artifact/*/buster/",
      "./scripts/docker/debian/buster/release.Dockerfile",
      false
    )

    DOCKER_IMAGES.focal_installed = dockerUtils.createDockerImageDesc(
      "ubuntu-focal-installed", dockerUtils.&idTesting,
      "./release-artifact/*/focal/",
      "./scripts/docker/ubuntu/focal/release.Dockerfile",
      false
    )

    DOCKER_IMAGES.bionic_installed = dockerUtils.createDockerImageDesc(
      "ubuntu-bionic-installed", dockerUtils.&idTesting,
      "./release-artifact/*/bionic/",
      "./scripts/docker/ubuntu/bionic/release.Dockerfile",
      false
    )

    DOCKER_IMAGES.fedora_33_installed = dockerUtils.createDockerImageDesc(
      "fedora-33-installed", dockerUtils.&idTesting,
      "./release-artifact/*/fedora33/",
      "./scripts/docker/fedora/33/release.Dockerfile",
      false
    )

    /* Build Elektra's documentation with this image.
     * Also contains latex for pdf creation.
     */
    DOCKER_IMAGES.buster_doc = dockerUtils.createDockerImageDesc(
      "debian-buster-doc", dockerUtils.&idTesting,
      "./scripts/docker/debian/buster",
      "./scripts/docker/debian/buster/doc.Dockerfile"
    )

  }
}

/* Generate release stages for release automation
 */
def generateReleaseStages() {
  def tasks = [:]

  tasks << buildRelease(
    "debian-buster",
    DOCKER_IMAGES.buster,
    params.debian_revision
  )

  tasks << buildRelease(
    "ubuntu-focal",
    DOCKER_IMAGES.focal,
    params.ubuntu_revision
  )

  tasks << buildRelease(
    "ubuntu-bionic",
    DOCKER_IMAGES.bionic,
    params.ubuntu_revision
  )

  tasks << buildRelease(
    "fedora-33",
    DOCKER_IMAGES.fedora_33,
    params.fedora_revision,
    true
  )

  return tasks

}

/* Generate Docker Build Stages with installed libelektra packages
 */
def generateDockerBuildStagesWithPackagesInstalled() {
  def tasks = [:]
  tasks << buildImageWithPackagesStage(
    DOCKER_IMAGES.focal_installed,
    "ubuntu-focal"
  )
  tasks << buildImageWithPackagesStage(
    DOCKER_IMAGES.bionic_installed,
    "ubuntu-bionic"
  )
  tasks << buildImageWithPackagesStage(
    DOCKER_IMAGES.fedora_33_installed,
    "fedora-33"
  )
  tasks << buildImageWithPackagesStage(
    DOCKER_IMAGES.buster_installed,
    "debian-buster"
  )

  tasks << buildDoc()

  return tasks
}

/* Generates Testing stages where installed packages are tested
 */
def generateInstalledPackagesTestStages() {
  def tasks = [:]
  tasks << testInstalledPackage(
    "ubuntu-focal-installed",
    DOCKER_IMAGES.focal_installed
  )
  tasks << testInstalledPackage(
    "ubuntu-bionic-installed",
    DOCKER_IMAGES.bionic_installed
  )
  tasks << testInstalledPackage(
    "fedora-33-installed",
    DOCKER_IMAGES.fedora_33_installed
  )

  tasks << testInstalledPackage(
    "debian-buster-installed",
    DOCKER_IMAGES.buster_installed
  )

  return tasks
}

/* Generate Publish Stages
 */
def generatePublishStages() {
  def tasks = [:]

  tasks << publish(
    "debian-buster",
    DOCKER_IMAGES.buster_installed.context,
    "buster",
    "buster",
    "DEB",
    params.debian_revision
  )

  tasks << publish(
    "ubuntu-focal",
    DOCKER_IMAGES.focal_installed.context,
    "focal",
    "focal",
    "DEB",
    params.ubuntu_revision
  )

  tasks << publish(
    "ubuntu-bionic",
    DOCKER_IMAGES.bionic_installed.context,
    "bionic",
    "bionic",
    "DEB",
    params.ubuntu_revision
  )

  tasks << publish(
    "fedora-33",
    DOCKER_IMAGES.fedora_33_installed.context,
    "fedora-33",
    "fedora-33",
    "RPM",
    params.fedora_revision
  )

  return tasks
}

/** Release stage
 *
 * Imports the gpg keys and runs the release script.
 * All relevant artifacts (build and test infos, packages, etc) are archived
 *
 * testName: used to identify the release and name the stage
 * image: which docker image should be used
 */
def buildRelease(testName, image, packageRevision='1', placeholderDir=false) {
  return [(testName): {
    stage(testName) {
      withDockerEnv(image, [DockerOpts.MOUNT_MIRROR]) {
        withCredentials([file(credentialsId: 'jenkins-key', variable: 'KEY'),
                         file(credentialsId: 'jenkins-secret-key', variable: 'SKEY')]) {
          sh "gpg --import $KEY"
          sh "gpg --import $SKEY"
          withEnv(["DEBSIGN_PROGRAM=gpg",
                   "DEBFULLNAME=Jenkins (User for Elektra automated build system)",
                   "DEBEMAIL=autobuilder@libelektra.org"]) {
            sh "rm -rf ./*"

            sh "git config --global user.name jenkins-release"
            sh "git config --global user.email jenkins@libelektra.org"
            def dirStructure = './'
            if (placeholderDir) {
              dirStructure = dirStructure + 'placeholder/placeholder/placeholder/placeholder'
            }
            dir(dirStructure) {
              dir('libelektra') {
                deleteDir()
                checkout scm
              }

              sh "sh libelektra/scripts/release/release.sh ${packageRevision}"
              sh "mv release.tar.gz ${testName}-release.tar.gz"

              utils.archive(["${testName}-release.tar.gz"])

              dir('libelektra') {
                sh "git bundle create libelektra.bundle --all"
                utils.archive(["libelektra.bundle"])
              }

              script {
                RELEASE_VERSION = sh(
                  script: 'sh libelektra/scripts/release/get-installed-version.sh',
                  returnStdout: true
                ).trim()
              }
            }
            deleteDir()
          }
        }
      }
    }
  }]
}

def testInstalledPackage(testName, image) {
  return [(testName): {
    stage(testName) {
      withDockerEnv(image, [DockerOpts.MOUNT_MIRROR]) {
        checkout scm

        sh "./scripts/release/release-tests.sh ./ ${RELEASE_VERSION} package OFF"
        sh "tar -czvf ${testName}-release.tar.gz ./${RELEASE_VERSION}"

        utils.archive(["${testName}-release.tar.gz"])
        deleteDir()

      }
    }
  }]
}


/* Publish changes and artifacts
 *
 * @param correspondingReleaseTestName corresponding name of the test stage in which artifcats
 *                                     necessaryfor this stage have been generated
 * @param context filepath under which packages are located
 * @param repoName name of the package repository
 * @param repoPrefix prefix of the package repository
 * @param packageType e.g. DEB, RPM
 * @param packageRevision revision number of the package
 */
def publish(correspondingReleaseTestName, context, repoName, repoPrefix, packageType, packageRevision) {
  return [(correspondingReleaseTestName): {
    stage(correspondingReleaseTestName) {
      withDockerEnv(DOCKER_IMAGES.buster) {
        copyArtifacts(
          filter: "artifacts/${correspondingReleaseTestName}/${correspondingReleaseTestName}-release.tar.gz",
          fingerprintArtifacts: true,
          projectName: '${JOB_NAME}',
          selector: specific('${BUILD_NUMBER}')
        )
        dir('release-artifact') {
          deleteDir()
          sh """\
tar -zxvf ../artifacts/${correspondingReleaseTestName}/${correspondingReleaseTestName}-release.tar.gz \
-C ./ --strip-components=1"""
        }
        dir('ftp') {
          deleteDir()
          // TODO: checkout ftp dir, add packages and push
          // sh "git clone https://github.com/ElektraInitiative/ftp.git ."
        }
        dir("copy") {
          deleteDir()
          sh "mv ../${context}* ./"
          switch(packageType) {
            case "DEB":
              release.publishDebPackages(
                'doc.libelektra.org',
                "/packaging/incoming/${repoName}/",
                repoName,
                repoPrefix,
                RELEASE_VERSION,
                packageRevision
              )
              break
            case "RPM":
              release.publishRpmPackages(
                'doc.libelektra.org',
                "/packaging/incoming/${repoName}/",
                repoName,
                packageRevision
              )
              break
            default:
              currentBuild.result = 'FAILURE'
              break
          }
        }
      }
    }
  }]
}

// /* Stage building and uploading the documentation */
def buildDoc() {
  def stageName = "Build Documentation"
  cmakeFlags = [
    'BUILD_PDF': 'ON',
    'BUILD_FULL': 'OFF',
    'BUILD_SHARED': 'OFF',
    'BUILD_STATIC': 'OFF',
    'BUILD_TESTING': 'OFF'
  ]
  return [(stageName): {
    maybeStage(stageName, params.generate_docu) {
      withDockerEnv(DOCKER_IMAGES.buster_doc) {
        sh "git config --global user.name jenkins-release"
        sh "git config --global user.email jenkins@libelektra.org"

        dir('build') {
          deleteDir()
          utils.cmake(env.WORKSPACE, cmakeFlags)
          sh "make html man"
        }

        dir('doc') {
          deleteDir()
          sh "git clone https://github.com/ElektraInitiative/doc.git ."
        }

        dir('doc/api') {
          dir(RELEASE_VERSION) {
            sh """\
cp -a ${WORKSPACE}/build/doc/html ${WORKSPACE}/build/doc/latex \
${WORKSPACE}/build/doc/man ./"""
          }
          sh "rm current"
          sh "ln -s ${RELEASE_VERSION} current"
          sh "git add current ${RELEASE_VERSION}"
        }

        dir('doc') {
          sh "git commit -a -m '${RELEASE_VERSION} Release'"
          sh "git bundle create docu.bundle --all"
          utils.archive(["docu.bundle"])
        }

        warnings parserConfigurations: [
          [parserName: 'Doxygen', pattern: 'build/doc/doxygen.log']
        ]

        deleteDir()
      }
    }
  }]
}


/* Returns a map with a closure that builds image
 *
 * @param image Image that needs to be build
 */
def buildImageWithPackagesStage(image, previousTaskName) {
  def taskname = "build/${image.id}/"
  return [(taskname): {
    stage(taskname) {
      node(PipelineConfig.instance.dockerNodeLabel) {
        echo "Starting ${env.STAGE_NAME} on ${env.NODE_NAME}"
        checkout scm

        copyArtifacts(
          filter: "artifacts/${previousTaskName}/${previousTaskName}-release.tar.gz",
          fingerprintArtifacts: true,
          projectName: '${JOB_NAME}',
          selector: specific('${BUILD_NUMBER}')
        )
        dir('release-artifact') {
          deleteDir()
          sh """\
tar -zxvf ../artifacts/${previousTaskName}/${previousTaskName}-release.tar.gz \
-C ./ --strip-components=1"""
        }

        dockerUtils.buildImage(image)
      }
    }
  }]
}
