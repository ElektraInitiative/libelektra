#!/usr/bin/env groovy

// Libraries
@Library('libelektra-shared') _

// Buildjob properties
properties([
  buildDiscarder(
    logRotator(
      artifactDaysToKeepStr: '31',
      artifactNumToKeepStr: '10'
    )
  ),
  parameters([
    string(
      defaultValue: '1',
      description: 'Debian package revision.',
      name: 'debian_revision',
      trim: true
    ),
    string(
      defaultValue: '1',
      description: 'Ubuntu package revision.',
      name: 'ubuntu_revision',
      trim: true
    ),
    string(
      defaultValue: '1',
      description: 'Fedora package revision.',
      name: 'fedora_revision',
      trim: true
    )
  ])
])

pipelineConfig {
  // uncomment if you you want to overwrite these values
  // dockerNodeLabel = 'docker'
  // registry = 'hub.libelektra.org'
  now = new Date()
}

DOCKER_IMAGES = [:]  // Containers docker image descriptions, populated during
                     // dockerInit()

RELEASE_VERSION = '' // release version, set during release build and used
                     // by the documentation stage

// Stages
stage('Init docker images') {
  dockerInit()
}

stage('Pull docker images') {
  parallel dockerUtils.generateDockerPullStages(DOCKER_IMAGES)
}

maybeStage('Build docker images', DOCKER_IMAGES.any { img -> !img.value.exists }) {
  lock('docker-images') {
        parallel dockerUtils.generateDockerBuildStages(DOCKER_IMAGES)
  }
}

stage('Release') {
  milestone label: 'Release'
  parallel generateReleaseStages()
}

stage('Build docker images for package testing') {
  parallel generateDockerBuildStagesWithPackagesInstalled()
}

stage('Test packages') {
  parallel generateInstalledPackagesTestStages()
}

// Pause pipeline and wait for approval to run publishing steps
input(message: 'Publish Release?', ok: 'Yes')

stage('Publish') {
  parallel generatePublishStages()
}

/**************/
/* Generators */
/**************/

/**
 *  Populate DOCKER_IMAGES with data
 *
 * For this we need a checkout of the scm to generate the hash for the
 * Dockerfiles which indicates if a rebuild of the images is needed
 */
def dockerInit() {
  node('master') {
    echo 'Processing DOCKER_IMAGES'
    checkout scm

    /* Test and build release artifacts with these images. */
    DOCKER_IMAGES.buster = dockerUtils.createDockerImageDesc(
      'debian-buster', dockerUtils.&idTesting,
      './scripts/docker/debian/buster',
      './scripts/docker/debian/buster/Dockerfile'
    )

    DOCKER_IMAGES.focal = dockerUtils.createDockerImageDesc(
      'ubuntu-focal', dockerUtils.&idTesting,
      './scripts/docker/ubuntu/focal',
      './scripts/docker/ubuntu/focal/Dockerfile'
    )

    DOCKER_IMAGES.bionic = dockerUtils.createDockerImageDesc(
      'ubuntu-bionic', dockerUtils.&idTesting,
      './scripts/docker/ubuntu/bionic',
      './scripts/docker/ubuntu/bionic/Dockerfile'
    )

    DOCKER_IMAGES.fedora_33 = dockerUtils.createDockerImageDesc(
      'fedora-33', dockerUtils.&idTesting,
      './scripts/docker/fedora/33',
      './scripts/docker/fedora/33/Dockerfile'
    )

    /* Install and test the built packages with theses images. */
    DOCKER_IMAGES.buster_installed = dockerUtils.createDockerImageDesc(
      'debian-buster-installed', dockerUtils.&idArtifact,
      './release-artifact/*/buster/',
      './scripts/docker/debian/buster/release.Dockerfile',
      false
    )

    DOCKER_IMAGES.focal_installed = dockerUtils.createDockerImageDesc(
      'ubuntu-focal-installed', dockerUtils.&idArtifact,
      './release-artifact/*/focal/',
      './scripts/docker/ubuntu/focal/release.Dockerfile',
      false
    )

    DOCKER_IMAGES.bionic_installed = dockerUtils.createDockerImageDesc(
      'ubuntu-bionic-installed', dockerUtils.&idArtifact,
      './release-artifact/*/bionic/',
      './scripts/docker/ubuntu/bionic/release.Dockerfile',
      false
    )

    DOCKER_IMAGES.fedora_33_installed = dockerUtils.createDockerImageDesc(
      'fedora-33-installed', dockerUtils.&idArtifact,
      './release-artifact/*/fedora33/',
      './scripts/docker/fedora/33/release.Dockerfile',
      false
    )

    /* Build Elektra's documentation with this image.
     * Also contains latex for pdf creation.
     */
    DOCKER_IMAGES.buster_doc = dockerUtils.createDockerImageDesc(
      'debian-buster-doc', dockerUtils.&idTesting,
      './scripts/docker/debian/buster',
      './scripts/docker/debian/buster/doc.Dockerfile'
    )
  }
}

/**
 *  Generate release stages for release automation
 */
def generateReleaseStages() {
  def tasks = [:]

  tasks << buildRelease(
    'debian-buster',
    DOCKER_IMAGES.buster,
    params.debian_revision,
    true // bundle repository
  )

  tasks << buildRelease(
    'ubuntu-focal',
    DOCKER_IMAGES.focal,
    params.ubuntu_revision
  )

  tasks << buildRelease(
    'ubuntu-bionic',
    DOCKER_IMAGES.bionic,
    params.ubuntu_revision
  )

  tasks << buildRelease(
    'fedora-33',
    DOCKER_IMAGES.fedora_33,
    params.fedora_revision,
    false, // do not bundle git repo
    true // use placeholder dirs
  )

  return tasks
}

/**
 *  Generate Docker Build Stages with installed libelektra packages
 */
def generateDockerBuildStagesWithPackagesInstalled() {
  def tasks = [:]
  tasks << buildImageWithPackagesStage(
    DOCKER_IMAGES.focal_installed,
    'ubuntu-focal'
  )
  tasks << buildImageWithPackagesStage(
    DOCKER_IMAGES.bionic_installed,
    'ubuntu-bionic'
  )
  tasks << buildImageWithPackagesStage(
    DOCKER_IMAGES.fedora_33_installed,
    'fedora-33'
  )
  tasks << buildImageWithPackagesStage(
    DOCKER_IMAGES.buster_installed,
    'debian-buster'
  )

  return tasks
}

/**
 *  Generates Testing stages where installed packages are tested
 */
def generateInstalledPackagesTestStages() {
  def tasks = [:]
  tasks << testInstalledPackage(
    'ubuntu-focal-installed',
    DOCKER_IMAGES.focal_installed
  )
  tasks << testInstalledPackage(
    'ubuntu-bionic-installed',
    DOCKER_IMAGES.bionic_installed
  )
  tasks << testInstalledPackage(
    'fedora-33-installed',
    DOCKER_IMAGES.fedora_33_installed
  )

  tasks << testInstalledPackage(
    'debian-buster-installed',
    DOCKER_IMAGES.buster_installed
  )

  return tasks
}

/**
 *  Generates stages to publish deb packages
 */
def generateDebPackagePublishStages() {
  def tasks = [:]

  tasks << publish(
    'debian-buster',
    DOCKER_IMAGES.buster_installed.context,
    'buster',
    'buster',
    release.&publishDebPackages,
    params.debian_revision
  )

  tasks << publish(
    'ubuntu-focal',
    DOCKER_IMAGES.focal_installed.context,
    'focal',
    'focal',
    release.&publishDebPackages,
    params.ubuntu_revision
  )

  tasks << publish(
    'ubuntu-bionic',
    DOCKER_IMAGES.bionic_installed.context,
    'bionic',
    'bionic',
    release.&publishDebPackages,
    params.ubuntu_revision
  )

  return tasks
}

/**
 * Runs the debian package stages sequential
 *
 * Necessary to prevent race conditions from `aptly`.
 */
def publishDebPackagesStage() {
  def stageName = 'publish-deb'
  return [(stageName): {
    stage(stageName) {
      sequential generateDebPackagePublishStages()
    }
  }]
}

/**
 *  Generate Publish Stages
 */
def generatePublishStages() {
  def tasks = [:]

  tasks << publishDebPackagesStage()

  // RPM packges can be published in parallel because
  // no shared DB is used.
  tasks << publish(
    'fedora-33',
    DOCKER_IMAGES.fedora_33_installed.context,
    'fedora-33',
    'fedora-33',
    release.&publishRpmPackages,
    params.fedora_revision
  )

  tasks << buildDoc()

  // publish source package built in debian-buster stage
  tasks << publishSource('debian-buster')
  // publish main repo which got modified during the
  // debian-buster release stage
  tasks << publishMainRepo('debian-buster')

  return tasks
}

/**
 * Release stage
 *
 * Imports the gpg keys and runs the release script.
 * All relevant artifacts (build and test infos, packages, etc) are archived.
 * The Elektra version is queried and assigned to the pipeline
 * variable `RELEASE_VERSION`
 *
 * @param stageName used to identify the release and name the stage
 * @param image which docker image should be used
 * @param bundleRepo if the libelektra repository should be bundled and archived
 * @param placeholderDir if placeholder directories should be used to extend
 *                       the base path
 */
def buildRelease(stageName, image, packageRevision='1',
                 bundleRepo=false, placeholderDir=false) {
  return [(stageName): {
    stage(stageName) {
      withDockerEnv(image, [DockerOpts.MOUNT_MIRROR]) {
        withCredentials([file(credentialsId: 'jenkins-key', variable: 'KEY'),
                         file(credentialsId: 'jenkins-secret-key', variable: 'SKEY')]) {
          sh "gpg --import $KEY"
          sh "gpg --import $SKEY"
          sh 'rm -rf ./*'

          configureGitUser()
          def dirStructure = './'
          if (placeholderDir) {
            dirStructure = dirStructure + 'placeholder/placeholder/placeholder/placeholder'
          }
          dir(dirStructure) {
            dir('libelektra') {
              deleteDir()
              checkout scm
            }
            sh "sh libelektra/scripts/release/release.sh ${packageRevision}"
            sh "mv release.tar.gz ${stageName}-release.tar.gz"
            utils.archive(["${stageName}-release.tar.gz"])

            if (bundleRepo) {
              dir('libelektra') {
                sh 'git bundle create libelektra.bundle --all'
                utils.archive(['libelektra.bundle'])
              }
            }

            script {
              RELEASE_VERSION = sh(
                script: 'sh libelektra/scripts/release/get-installed-version.sh',
                returnStdout: true
              ).trim()
            }
          }
          deleteDir()
        }
      }
    }
  }]
}

/**
 * Tests installed packages in docker container and archives results
 *
 * @param stageName used to identify the stage
 * @param image which docker image should be used
 */
def testInstalledPackage(stageName, image) {
  return [(stageName): {
    stage(stageName) {
      withDockerEnv(image, [DockerOpts.MOUNT_MIRROR]) {
        checkout scm

        sh "./scripts/release/release-tests.sh ./ ${RELEASE_VERSION} package OFF"
        sh "tar -czvf ${stageName}-release.tar.gz ./${RELEASE_VERSION}"

        utils.archive(["${stageName}-release.tar.gz"])
        deleteDir()
      }
    }
  }]
}

/**
 * Publish changes and artifacts
 *
 * @param correspondingReleaseStageName corresponding name of the test stage in which artifcats
 *                                      necessary for this stage have been generated
 * @param context filepath under which packages are located
 * @param repoName name of the package repository
 * @param repoPrefix prefix of the package repository
 * @param publishPackagesFun closure that publishes packages to a repository
 * @param packageRevision revision number of the package
 */
def publish(correspondingReleaseStageName, context, repoName,
            repoPrefix, publishPackagesFun, packageRevision) {
  return [(correspondingReleaseStageName): {
    stage(correspondingReleaseStageName) {
      withDockerEnv(DOCKER_IMAGES.buster) {
        copyReleaseArtifact(correspondingReleaseStageName)
        dir('copy') {
          deleteDir()
          sh "mv ../${context}* ./"

          publishPackagesFun(
            'doc.libelektra.org',
            "/packaging/incoming/${repoName}/",
            repoName,
            repoPrefix,
            RELEASE_VERSION,
            packageRevision
          )
        }
      }
    }
  }]
}

/**
 * Publish source package to ftp repo
 *
 * @param artifactStageName artifact to get source package from
 */
def publishSource(artifactStageName) {
  def stageName = 'publishSourcePackage'
  return [(stageName): {
    stage(stageName) {
      withDockerEnv(DOCKER_IMAGES.buster) {
        configureGitUser()
        copyReleaseArtifact(artifactStageName)
        dir('ftp') {
          deleteDir()
          git branch: 'master',
              url: 'https://github.com/ElektraInitiative/ftp.git'
          sh 'cp ../release-artifact/*/*.tar.gz* ./releases/'
          sh "git commit -a -m 'release: add ${RELEASE_VERSION}'"
          pushGitRepo('ftp')
        }
      }
    }
  }]
}

/**
 * Publishes main repository which got archived in the release stage
 *
 * @param  artifactStageName stage name under which the main repo
 *                           got archived
 */
def publishMainRepo(artifactStageName) {
  def stageName = 'publishMainRepo'
  return [(stageName): {
    stage(stageName) {
      withDockerEnv(DOCKER_IMAGES.buster) {
        configureGitUser()
        copyArtifacts(
          filter: "artifacts/${artifactStageName}/libelektra.bundle",
          fingerprintArtifacts: true,
          projectName: '${JOB_NAME}',
          selector: specific('${BUILD_NUMBER}')
        )

        dir('libelektra') {
          deleteDir()
          git branch: 'master',
              url: 'https://github.com/ElektraInitiative/libelektra.git'
          sh "git bundle verify ${WORKSPACE}/artifacts/${artifactStageName}/libelektra.bundle"
          sh "git pull --ff-only ${WORKSPACE}/artifacts/${artifactStageName}/libelektra.bundle"
          pushGitRepo('libelektra')
        }
      }
    }
  }]
}

/**
 * Stage building and uploading the documentation
 */
def buildDoc() {
  def stageName = 'Build Documentation'
  cmakeFlags = [
    'BUILD_PDF': 'ON',
    'BUILD_FULL': 'OFF',
    'BUILD_SHARED': 'OFF',
    'BUILD_STATIC': 'OFF',
    'BUILD_TESTING': 'OFF'
  ]
  return [(stageName): {
    stage(stageName) {
      withDockerEnv(DOCKER_IMAGES.buster_doc) {
        configureGitUser()

        dir('build') {
          deleteDir()
          utils.cmake(env.WORKSPACE, cmakeFlags)
          sh 'make html man'
        }

        dir('doc') {
          deleteDir()
          git branch: 'master',
              url: 'https://github.com/ElektraInitiative/doc.git'
        }

        dir('doc/api') {
          dir(RELEASE_VERSION) {
            sh """\
cp -a ${WORKSPACE}/build/doc/html ${WORKSPACE}/build/doc/latex \
${WORKSPACE}/build/doc/man ./"""
          }
          sh 'rm latest'
          sh "ln -s ${RELEASE_VERSION} latest"
          sh "git add latest ${RELEASE_VERSION}"
        }

        dir('doc') {
          sh "git commit -m '${RELEASE_VERSION} Release'"
          // push to github mirror
          pushGitRepo('doc')
          withCredentials([sshUserPrivateKey(credentialsId: "community-ssh-git", keyFileVariable: "privateSshKey", usernameVariable: 'GIT_USERNAME')]) {
            // add community server to known hosts
            sh "mkdir -p ~/.ssh/ && ssh-keyscan -t rsa doc.libelektra.org >> ~/.ssh/known_hosts"
            // add community mirror of doc repo as remote
            sh "git remote add community ${GIT_USERNAME}@doc.libelektra.org:/srv/libelektra"
          }
          // push to community mirror
          sshagent(['community-ssh-git']) {
            sh "git push community master"
          }
        }

        warnings parserConfigurations: [
          [parserName: 'Doxygen', pattern: 'build/doc/doxygen.log']
        ]

        deleteDir()
      }
    }
  }]
}

/**
 * Build image with installed packges
 *
 * Copies artifact containing packages built in previous stage
 * and builds an image which copies and install these packages.
 *
 * @param image Image that needs to be build
 */
def buildImageWithPackagesStage(image, previousTaskName) {
  def taskname = "build/${image.id}/"
  return [(taskname): {
    stage(taskname) {
      node(PipelineConfig.instance.dockerNodeLabel) {
        echo "Starting ${env.STAGE_NAME} on ${env.NODE_NAME}"
        checkout scm
        copyReleaseArtifact(previousTaskName)
        dockerUtils.buildImage(image)
      }
    }
  }]
}

/**
 * Copy release artifact from previous stage and extract it
 * @param  artifactStageName stage name under which the artifact
 *                           got archived
 */
def copyReleaseArtifact(artifactStageName) {
  copyArtifacts(
    filter: "artifacts/${artifactStageName}/${artifactStageName}-release.tar.gz",
    fingerprintArtifacts: true,
    projectName: '${JOB_NAME}',
    selector: specific('${BUILD_NUMBER}')
  )
  dir('release-artifact') {
    deleteDir()
    sh """\
tar -zxvf ${WORKSPACE}/artifacts/${artifactStageName}/${artifactStageName}-release.tar.gz \
-C ./ --strip-components=1"""
  }
}

/**
 * Push git repo
 * Currently the best way according to
 * https://github.com/jenkinsci/pipeline-examples/blob/master/pipeline-examples/push-git-repo/pushGitRepo.groovy
 * @param  repoName name of the git repo
 */
def pushGitRepo(repoName) {
  def gitOrg = 'ElektraInitiative'
  def credentialsId = 'jenkins-publish-credentials'
  withCredentials([usernamePassword(credentialsId: "${credentialsId}", passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
    sh("git push https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/${gitOrg}/${repoName}.git")
  }
}

/**
 * Configures git user to elektrabot
 */
def configureGitUser() {
  sh 'git config --global user.name elektrabot'
  sh 'git config --global user.email elektrabot@libelektra.org'
}
